"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WaitTracker = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const typedi_1 = require("typedi");
const typeorm_1 = require("typeorm");
const DateUtils_1 = require("typeorm/util/DateUtils");
const config_1 = __importDefault(require("./config"));
const ResponseHelper = __importStar(require("./ResponseHelper"));
const WorkflowRunner_1 = require("./WorkflowRunner");
const recoverEvents_1 = require("./eventbus/MessageEventBus/recoverEvents");
const repositories_1 = require("./databases/repositories");
const ownership_service_1 = require("./services/ownership.service");
let WaitTracker = exports.WaitTracker = class WaitTracker {
    constructor(executionRepository, ownershipService) {
        this.executionRepository = executionRepository;
        this.ownershipService = ownershipService;
        this.waitingExecutions = {};
        this.mainTimer = setInterval(() => {
            void this.getWaitingExecutions();
        }, 60000);
        void this.getWaitingExecutions();
    }
    async getWaitingExecutions() {
        n8n_workflow_1.LoggerProxy.debug('Wait tracker querying database for waiting executions');
        const findQuery = {
            select: ['id', 'waitTill'],
            where: {
                waitTill: (0, typeorm_1.LessThanOrEqual)(new Date(Date.now() + 70000)),
                status: (0, typeorm_1.Not)('crashed'),
            },
            order: {
                waitTill: 'ASC',
            },
        };
        const dbType = config_1.default.getEnv('database.type');
        if (dbType === 'sqlite') {
            findQuery.where.waitTill = (0, typeorm_1.LessThanOrEqual)(DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(new Date(Date.now() + 70000)));
        }
        const executions = await this.executionRepository.findMultipleExecutions(findQuery);
        if (executions.length === 0) {
            return;
        }
        const executionIds = executions.map((execution) => execution.id).join(', ');
        n8n_workflow_1.LoggerProxy.debug(`Wait tracker found ${executions.length} executions. Setting timer for IDs: ${executionIds}`);
        for (const execution of executions) {
            const executionId = execution.id;
            if (this.waitingExecutions[executionId] === undefined) {
                const triggerTime = execution.waitTill.getTime() - new Date().getTime();
                this.waitingExecutions[executionId] = {
                    executionId,
                    timer: setTimeout(() => {
                        this.startExecution(executionId);
                    }, triggerTime),
                };
            }
        }
    }
    async stopExecution(executionId) {
        if (this.waitingExecutions[executionId] !== undefined) {
            clearTimeout(this.waitingExecutions[executionId].timer);
            delete this.waitingExecutions[executionId];
        }
        const execution = await this.executionRepository.findSingleExecution(executionId, {
            includeData: true,
        });
        if (!execution) {
            throw new Error(`The execution ID "${executionId}" could not be found.`);
        }
        if (!['new', 'unknown', 'waiting', 'running'].includes(execution.status)) {
            throw new Error(`Only running or waiting executions can be stopped and ${executionId} is currently ${execution.status}.`);
        }
        let fullExecutionData;
        try {
            fullExecutionData = ResponseHelper.unflattenExecutionData(execution);
        }
        catch (error) {
            await (0, recoverEvents_1.recoverExecutionDataFromEventLogMessages)(executionId, [], true);
            const restoredExecution = await typedi_1.Container.get(repositories_1.ExecutionRepository).findSingleExecution(executionId, {
                includeData: true,
                unflattenData: true,
            });
            if (!restoredExecution) {
                throw new Error(`Execution ${executionId} could not be recovered or canceled.`);
            }
            fullExecutionData = restoredExecution;
        }
        const error = new n8n_workflow_1.WorkflowOperationError('Workflow-Execution has been canceled!');
        fullExecutionData.data.resultData.error = {
            ...error,
            message: error.message,
            stack: error.stack,
        };
        fullExecutionData.stoppedAt = new Date();
        fullExecutionData.waitTill = null;
        fullExecutionData.status = 'canceled';
        await typedi_1.Container.get(repositories_1.ExecutionRepository).updateExistingExecution(executionId, fullExecutionData);
        return {
            mode: fullExecutionData.mode,
            startedAt: new Date(fullExecutionData.startedAt),
            stoppedAt: fullExecutionData.stoppedAt ? new Date(fullExecutionData.stoppedAt) : undefined,
            finished: fullExecutionData.finished,
            status: fullExecutionData.status,
        };
    }
    startExecution(executionId) {
        n8n_workflow_1.LoggerProxy.debug(`Wait tracker resuming execution ${executionId}`, { executionId });
        delete this.waitingExecutions[executionId];
        (async () => {
            const fullExecutionData = await this.executionRepository.findSingleExecution(executionId, {
                includeData: true,
                unflattenData: true,
            });
            if (!fullExecutionData) {
                throw new Error(`The execution with the id "${executionId}" does not exist.`);
            }
            if (fullExecutionData.finished) {
                throw new Error('The execution did succeed and can so not be started again.');
            }
            if (!fullExecutionData.workflowData.id) {
                throw new Error('Only saved workflows can be resumed.');
            }
            const workflowId = fullExecutionData.workflowData.id;
            const user = await this.ownershipService.getWorkflowOwnerCached(workflowId);
            const data = {
                executionMode: fullExecutionData.mode,
                executionData: fullExecutionData.data,
                workflowData: fullExecutionData.workflowData,
                userId: user.id,
            };
            const workflowRunner = new WorkflowRunner_1.WorkflowRunner();
            await workflowRunner.run(data, false, false, executionId);
        })().catch((error) => {
            n8n_workflow_1.ErrorReporterProxy.error(error);
            n8n_workflow_1.LoggerProxy.error(`There was a problem starting the waiting execution with id "${executionId}": "${error.message}"`, { executionId });
        });
    }
};
exports.WaitTracker = WaitTracker = __decorate([
    (0, typedi_1.Service)(),
    __metadata("design:paramtypes", [repositories_1.ExecutionRepository,
        ownership_service_1.OwnershipService])
], WaitTracker);
//# sourceMappingURL=WaitTracker.js.map