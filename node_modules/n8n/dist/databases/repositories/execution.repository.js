"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecutionRepository = void 0;
const typedi_1 = require("typedi");
const typeorm_1 = require("typeorm");
const ExecutionEntity_1 = require("../entities/ExecutionEntity");
const flatted_1 = require("flatted");
const n8n_workflow_1 = require("n8n-workflow");
const executionData_repository_1 = require("./executionData.repository");
const executionHelpers_1 = require("../../executions/executionHelpers");
const ExecutionMetadata_1 = require("../entities/ExecutionMetadata");
const DateUtils_1 = require("typeorm/util/DateUtils");
const n8n_core_1 = require("n8n-core");
const config_1 = __importDefault(require("../../config"));
function parseFiltersToQueryBuilder(qb, filters) {
    if (filters === null || filters === void 0 ? void 0 : filters.status) {
        qb.andWhere('execution.status IN (:...workflowStatus)', {
            workflowStatus: filters.status,
        });
    }
    if (filters === null || filters === void 0 ? void 0 : filters.finished) {
        qb.andWhere({ finished: filters.finished });
    }
    if ((filters === null || filters === void 0 ? void 0 : filters.metadata) && (0, executionHelpers_1.isAdvancedExecutionFiltersEnabled)()) {
        qb.leftJoin(ExecutionMetadata_1.ExecutionMetadata, 'md', 'md.executionId = execution.id');
        for (const md of filters.metadata) {
            qb.andWhere('md.key = :key AND md.value = :value', md);
        }
    }
    if (filters === null || filters === void 0 ? void 0 : filters.startedAfter) {
        qb.andWhere({
            startedAt: (0, typeorm_1.MoreThanOrEqual)(DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(new Date(filters.startedAfter))),
        });
    }
    if (filters === null || filters === void 0 ? void 0 : filters.startedBefore) {
        qb.andWhere({
            startedAt: (0, typeorm_1.LessThanOrEqual)(DateUtils_1.DateUtils.mixedDateToUtcDatetimeString(new Date(filters.startedBefore))),
        });
    }
    if (filters === null || filters === void 0 ? void 0 : filters.workflowId) {
        qb.andWhere({
            workflowId: filters.workflowId,
        });
    }
}
let ExecutionRepository = exports.ExecutionRepository = class ExecutionRepository extends typeorm_1.Repository {
    constructor(dataSource, executionDataRepository) {
        super(ExecutionEntity_1.ExecutionEntity, dataSource.manager);
        this.executionDataRepository = executionDataRepository;
    }
    async findMultipleExecutions(queryParams, options) {
        if (options === null || options === void 0 ? void 0 : options.includeData) {
            if (!queryParams.relations) {
                queryParams.relations = [];
            }
            queryParams.relations.push('executionData');
        }
        const executions = await this.find(queryParams);
        if ((options === null || options === void 0 ? void 0 : options.includeData) && (options === null || options === void 0 ? void 0 : options.unflattenData)) {
            return executions.map((execution) => {
                const { executionData, ...rest } = execution;
                return {
                    ...rest,
                    data: (0, flatted_1.parse)(executionData.data),
                    workflowData: executionData.workflowData,
                };
            });
        }
        else if (options === null || options === void 0 ? void 0 : options.includeData) {
            return executions.map((execution) => {
                const { executionData, ...rest } = execution;
                return {
                    ...rest,
                    data: execution.executionData.data,
                    workflowData: execution.executionData.workflowData,
                };
            });
        }
        return executions.map((execution) => {
            const { executionData, ...rest } = execution;
            return rest;
        });
    }
    async findSingleExecution(id, options) {
        const whereClause = {
            where: {
                id,
                ...options === null || options === void 0 ? void 0 : options.where,
            },
        };
        if (options === null || options === void 0 ? void 0 : options.includeData) {
            whereClause.relations = ['executionData'];
        }
        const execution = await this.findOne(whereClause);
        if (!execution) {
            return undefined;
        }
        const { executionData, ...rest } = execution;
        if ((options === null || options === void 0 ? void 0 : options.includeData) && (options === null || options === void 0 ? void 0 : options.unflattenData)) {
            return {
                ...rest,
                data: (0, flatted_1.parse)(execution.executionData.data),
                workflowData: execution.executionData.workflowData,
            };
        }
        else if (options === null || options === void 0 ? void 0 : options.includeData) {
            return {
                ...rest,
                data: execution.executionData.data,
                workflowData: execution.executionData.workflowData,
            };
        }
        return rest;
    }
    async createNewExecution(execution) {
        const { data, workflowData, ...rest } = execution;
        const newExecution = await this.save(rest);
        await this.executionDataRepository.save({
            execution: newExecution,
            workflowData,
            data: (0, flatted_1.stringify)(data),
        });
        return newExecution;
    }
    async updateExistingExecution(executionId, execution) {
        const { id, data, workflowData, startedAt, ...executionInformation } = execution;
        if (Object.keys(executionInformation).length > 0) {
            await this.update({ id: executionId }, executionInformation);
        }
        if (data || workflowData) {
            const executionData = {};
            if (workflowData) {
                executionData.workflowData = workflowData;
            }
            if (data) {
                executionData.data = (0, flatted_1.stringify)(data);
            }
            await this.executionDataRepository.update({ executionId }, executionData);
        }
    }
    async deleteExecution(executionId, deferBinaryDataDeletion = false) {
        const binaryDataManager = n8n_core_1.BinaryDataManager.getInstance();
        if (deferBinaryDataDeletion) {
            await binaryDataManager.markDataForDeletionByExecutionId(executionId);
        }
        else {
            await binaryDataManager.deleteBinaryDataByExecutionIds([executionId]);
        }
        return this.delete({ id: executionId });
    }
    async countExecutions(filters, accessibleWorkflowIds, currentlyRunningExecutions, isOwner) {
        const dbType = config_1.default.getEnv('database.type');
        if (dbType !== 'postgresdb' || (filters && Object.keys(filters).length > 0) || !isOwner) {
            const query = this.createQueryBuilder('execution').andWhere('execution.workflowId IN (:...accessibleWorkflowIds)', { accessibleWorkflowIds });
            if (currentlyRunningExecutions.length > 0) {
                query.andWhere('execution.id NOT IN (:...currentlyRunningExecutions)', {
                    currentlyRunningExecutions,
                });
            }
            parseFiltersToQueryBuilder(query, filters);
            const count = await query.getCount();
            return { count, estimated: false };
        }
        try {
            const estimateRowsNumberSql = "SELECT n_live_tup FROM pg_stat_all_tables WHERE relname = 'execution_entity';";
            const rows = (await this.query(estimateRowsNumberSql));
            const estimate = parseInt(rows[0].n_live_tup, 10);
            if (estimate > 100000) {
                return { count: estimate, estimated: true };
            }
        }
        catch (error) {
            if (error instanceof Error) {
                n8n_workflow_1.LoggerProxy.warn(`Failed to get executions count from Postgres: ${error.message}`, {
                    error,
                });
            }
        }
        const count = await this.count({
            where: {
                workflowId: (0, typeorm_1.In)(accessibleWorkflowIds),
            },
        });
        return { count, estimated: false };
    }
    async searchExecutions(filters, limit, excludedExecutionIds, accessibleWorkflowIds, additionalFilters) {
        if (accessibleWorkflowIds.length === 0) {
            return [];
        }
        const query = this.createQueryBuilder('execution')
            .select([
            'execution.id',
            'execution.finished',
            'execution.mode',
            'execution.retryOf',
            'execution.retrySuccessId',
            'execution.status',
            'execution.startedAt',
            'execution.stoppedAt',
            'execution.workflowId',
            'execution.waitTill',
            'workflow.name',
        ])
            .innerJoin('execution.workflow', 'workflow')
            .limit(limit)
            .orderBy({ 'execution.id': 'DESC' })
            .andWhere('execution.workflowId IN (:...accessibleWorkflowIds)', { accessibleWorkflowIds });
        if (excludedExecutionIds.length > 0) {
            query.andWhere('execution.id NOT IN (:...excludedExecutionIds)', { excludedExecutionIds });
        }
        if (additionalFilters === null || additionalFilters === void 0 ? void 0 : additionalFilters.lastId) {
            query.andWhere('execution.id < :lastId', { lastId: additionalFilters.lastId });
        }
        if (additionalFilters === null || additionalFilters === void 0 ? void 0 : additionalFilters.firstId) {
            query.andWhere('execution.id > :firstId', { firstId: additionalFilters.firstId });
        }
        parseFiltersToQueryBuilder(query, filters);
        const executions = await query.getMany();
        return executions.map((execution) => {
            const { workflow, waitTill, ...rest } = execution;
            return {
                ...rest,
                waitTill: waitTill !== null && waitTill !== void 0 ? waitTill : undefined,
                workflowName: workflow.name,
            };
        });
    }
    async deleteExecutions(filters, accessibleWorkflowIds, deleteConditions) {
        if (!(deleteConditions === null || deleteConditions === void 0 ? void 0 : deleteConditions.deleteBefore) && !(deleteConditions === null || deleteConditions === void 0 ? void 0 : deleteConditions.ids)) {
            throw new Error('Either "deleteBefore" or "ids" must be present in the request body');
        }
        const query = this.createQueryBuilder('execution')
            .select(['execution.id'])
            .andWhere('execution.workflowId IN (:...accessibleWorkflowIds)', { accessibleWorkflowIds });
        if (deleteConditions.deleteBefore) {
            query.andWhere('execution.startedAt <= :deleteBefore', {
                deleteBefore: deleteConditions.deleteBefore,
            });
            parseFiltersToQueryBuilder(query, filters);
        }
        else if (deleteConditions.ids) {
            query.andWhere('execution.id IN (:...executionIds)', { executionIds: deleteConditions.ids });
        }
        const executions = await query.getMany();
        if (!executions.length) {
            if (deleteConditions.ids) {
                n8n_workflow_1.LoggerProxy.error('Failed to delete an execution due to insufficient permissions', {
                    executionIds: deleteConditions.ids,
                });
            }
            return;
        }
        const executionIds = executions.map(({ id }) => id);
        const binaryDataManager = n8n_core_1.BinaryDataManager.getInstance();
        await binaryDataManager.deleteBinaryDataByExecutionIds(executionIds);
        do {
            const batch = executionIds.splice(0, 500);
            await this.delete(batch);
        } while (executionIds.length > 0);
    }
};
exports.ExecutionRepository = ExecutionRepository = __decorate([
    (0, typedi_1.Service)(),
    __metadata("design:paramtypes", [typeorm_1.DataSource,
        executionData_repository_1.ExecutionDataRepository])
], ExecutionRepository);
//# sourceMappingURL=execution.repository.js.map