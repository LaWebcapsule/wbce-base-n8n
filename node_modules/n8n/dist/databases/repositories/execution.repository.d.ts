import { DataSource, Repository } from 'typeorm';
import type { FindManyOptions, FindOptionsWhere } from 'typeorm';
import { ExecutionEntity } from '../entities/ExecutionEntity';
import type { IExecutionBase, IExecutionDb, IExecutionFlattedDb, IExecutionResponse } from '../../Interfaces';
import type { IExecutionsSummary } from 'n8n-workflow';
import { ExecutionDataRepository } from './executionData.repository';
import type { IGetExecutionsQueryFilter } from '../../executions/executions.service';
export declare class ExecutionRepository extends Repository<ExecutionEntity> {
    private readonly executionDataRepository;
    constructor(dataSource: DataSource, executionDataRepository: ExecutionDataRepository);
    findMultipleExecutions(queryParams: FindManyOptions<ExecutionEntity>, options?: {
        unflattenData: true;
        includeData?: true;
    }): Promise<IExecutionResponse[]>;
    findMultipleExecutions(queryParams: FindManyOptions<ExecutionEntity>, options?: {
        unflattenData?: false | undefined;
        includeData?: true;
    }): Promise<IExecutionFlattedDb[]>;
    findMultipleExecutions(queryParams: FindManyOptions<ExecutionEntity>, options?: {
        unflattenData?: boolean;
        includeData?: boolean;
    }): Promise<IExecutionBase[]>;
    findSingleExecution(id: string, options?: {
        includeData: true;
        unflattenData: true;
        where?: FindOptionsWhere<ExecutionEntity>;
    }): Promise<IExecutionResponse | undefined>;
    findSingleExecution(id: string, options?: {
        includeData: true;
        unflattenData?: false | undefined;
        where?: FindOptionsWhere<ExecutionEntity>;
    }): Promise<IExecutionFlattedDb | undefined>;
    findSingleExecution(id: string, options?: {
        includeData?: boolean;
        unflattenData?: boolean;
        where?: FindOptionsWhere<ExecutionEntity>;
    }): Promise<IExecutionBase | undefined>;
    createNewExecution(execution: IExecutionDb): Promise<{
        waitTill?: Date | null | undefined;
        id?: string | undefined;
        mode: import("n8n-workflow").WorkflowExecuteMode;
        startedAt: Date;
        stoppedAt?: Date | undefined;
        workflowId?: string | undefined;
        finished: boolean;
        retryOf?: string | undefined;
        retrySuccessId?: string | undefined;
        status: import("n8n-workflow").ExecutionStatus;
    } & ExecutionEntity>;
    updateExistingExecution(executionId: string, execution: Partial<IExecutionResponse>): Promise<void>;
    deleteExecution(executionId: string, deferBinaryDataDeletion?: boolean): Promise<import("typeorm").DeleteResult>;
    countExecutions(filters: IGetExecutionsQueryFilter | undefined, accessibleWorkflowIds: string[], currentlyRunningExecutions: string[], isOwner: boolean): Promise<{
        count: number;
        estimated: boolean;
    }>;
    searchExecutions(filters: IGetExecutionsQueryFilter | undefined, limit: number, excludedExecutionIds: string[], accessibleWorkflowIds: string[], additionalFilters?: {
        lastId?: string;
        firstId?: string;
    }): Promise<IExecutionsSummary[]>;
    deleteExecutions(filters: IGetExecutionsQueryFilter | undefined, accessibleWorkflowIds: string[], deleteConditions: {
        deleteBefore?: Date;
        ids?: string[];
    }): Promise<void>;
}
