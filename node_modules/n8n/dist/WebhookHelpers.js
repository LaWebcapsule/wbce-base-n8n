"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWebhookBaseUrl = exports.executeWebhook = exports.encodeWebhookResponse = exports.decodeWebhookResponse = exports.getWorkflowWebhooks = exports.webhookRequestHandler = exports.WEBHOOK_METHODS = void 0;
const typedi_1 = require("typedi");
const get_1 = __importDefault(require("lodash/get"));
const stream_1 = __importDefault(require("stream"));
const util_1 = require("util");
const formidable_1 = __importDefault(require("formidable"));
const n8n_core_1 = require("n8n-core");
const n8n_workflow_1 = require("n8n-workflow");
const GenericHelpers = __importStar(require("./GenericHelpers"));
const ResponseHelper = __importStar(require("./ResponseHelper"));
const WorkflowHelpers = __importStar(require("./WorkflowHelpers"));
const WorkflowRunner_1 = require("./WorkflowRunner");
const WorkflowExecuteAdditionalData = __importStar(require("./WorkflowExecuteAdditionalData"));
const ActiveExecutions_1 = require("./ActiveExecutions");
const events_service_1 = require("./services/events.service");
const ownership_service_1 = require("./services/ownership.service");
const middlewares_1 = require("./middlewares");
const pipeline = (0, util_1.promisify)(stream_1.default.pipeline);
exports.WEBHOOK_METHODS = [
    'DELETE',
    'GET',
    'HEAD',
    'PATCH',
    'POST',
    'PUT',
];
const webhookRequestHandler = (webhookManager) => async (req, res) => {
    const { path } = req.params;
    const method = req.method;
    if (method !== 'OPTIONS' && !exports.WEBHOOK_METHODS.includes(method)) {
        return ResponseHelper.sendErrorResponse(res, new Error(`The method ${method} is not supported.`));
    }
    if ('origin' in req.headers) {
        if (webhookManager.getWebhookMethods) {
            try {
                const allowedMethods = await webhookManager.getWebhookMethods(path);
                res.header('Access-Control-Allow-Methods', ['OPTIONS', ...allowedMethods].join(', '));
            }
            catch (error) {
                return ResponseHelper.sendErrorResponse(res, error);
            }
        }
        res.header('Access-Control-Allow-Origin', req.headers.origin);
    }
    if (method === 'OPTIONS') {
        return ResponseHelper.sendSuccessResponse(res, {}, true, 204);
    }
    let response;
    try {
        response = await webhookManager.executeWebhook(req, res);
    }
    catch (error) {
        return ResponseHelper.sendErrorResponse(res, error);
    }
    if (response.noWebhookResponse !== true) {
        ResponseHelper.sendSuccessResponse(res, response.data, true, response.responseCode, response.headers);
    }
};
exports.webhookRequestHandler = webhookRequestHandler;
function getWorkflowWebhooks(workflow, additionalData, destinationNode, ignoreRestartWebhooks = false) {
    const returnData = [];
    let parentNodes;
    if (destinationNode !== undefined) {
        parentNodes = workflow.getParentNodes(destinationNode);
        parentNodes.push(destinationNode);
    }
    for (const node of Object.values(workflow.nodes)) {
        if (parentNodes !== undefined && !parentNodes.includes(node.name)) {
            continue;
        }
        returnData.push.apply(returnData, n8n_workflow_1.NodeHelpers.getNodeWebhooks(workflow, node, additionalData, ignoreRestartWebhooks));
    }
    return returnData;
}
exports.getWorkflowWebhooks = getWorkflowWebhooks;
function decodeWebhookResponse(response) {
    if (typeof response === 'object' &&
        typeof response.body === 'object' &&
        response.body['__@N8nEncodedBuffer@__']) {
        response.body = Buffer.from(response.body['__@N8nEncodedBuffer@__'], n8n_workflow_1.BINARY_ENCODING);
    }
    return response;
}
exports.decodeWebhookResponse = decodeWebhookResponse;
function encodeWebhookResponse(response) {
    if (typeof response === 'object' && Buffer.isBuffer(response.body)) {
        response.body = {
            '__@N8nEncodedBuffer@__': response.body.toString(n8n_workflow_1.BINARY_ENCODING),
        };
    }
    return response;
}
exports.encodeWebhookResponse = encodeWebhookResponse;
async function executeWebhook(workflow, webhookData, workflowData, workflowStartNode, executionMode, sessionId, runExecutionData, executionId, req, res, responseCallback, destinationNode) {
    var _a;
    const nodeType = workflow.nodeTypes.getByNameAndVersion(workflowStartNode.type, workflowStartNode.typeVersion);
    if (nodeType === undefined) {
        const errorMessage = `The type of the webhook node "${workflowStartNode.name}" is not known`;
        responseCallback(new Error(errorMessage), {});
        throw new ResponseHelper.InternalServerError(errorMessage);
    }
    const additionalKeys = {
        $executionId: executionId,
    };
    let user;
    if (((_a = workflowData.shared) === null || _a === void 0 ? void 0 : _a.length) &&
        workflowData.shared[0].user) {
        user = workflowData.shared[0].user;
    }
    else {
        try {
            user = await typedi_1.Container.get(ownership_service_1.OwnershipService).getWorkflowOwnerCached(workflowData.id);
        }
        catch (error) {
            throw new ResponseHelper.NotFoundError('Cannot find workflow');
        }
    }
    const additionalData = await WorkflowExecuteAdditionalData.getBase(user.id);
    const responseMode = workflow.expression.getSimpleParameterValue(workflowStartNode, webhookData.webhookDescription.responseMode, executionMode, additionalData.timezone, additionalKeys, undefined, 'onReceived');
    const responseCode = workflow.expression.getSimpleParameterValue(workflowStartNode, webhookData.webhookDescription.responseCode, executionMode, additionalData.timezone, additionalKeys, undefined, 200);
    const responseData = workflow.expression.getSimpleParameterValue(workflowStartNode, webhookData.webhookDescription.responseData, executionMode, additionalData.timezone, additionalKeys, undefined, 'firstEntryJson');
    if (!['onReceived', 'lastNode', 'responseNode'].includes(responseMode)) {
        const errorMessage = `The response mode '${responseMode}' is not valid!`;
        responseCallback(new Error(errorMessage), {});
        throw new ResponseHelper.InternalServerError(errorMessage);
    }
    additionalData.httpRequest = req;
    additionalData.httpResponse = res;
    const binaryData = workflow.expression.getSimpleParameterValue(workflowStartNode, '={{$parameter["options"]["binaryData"]}}', executionMode, additionalData.timezone, additionalKeys, undefined, false);
    let didSendResponse = false;
    let runExecutionDataMerge = {};
    try {
        let webhookResultData;
        if (!binaryData) {
            const { contentType, encoding } = req;
            if (contentType === 'multipart/form-data') {
                const form = (0, formidable_1.default)({
                    multiples: true,
                    encoding: encoding,
                });
                req.body = await new Promise((resolve) => {
                    form.parse(req, async (err, data, files) => {
                        for (const key in data) {
                            if (Array.isArray(data[key]) && data[key].length === 1) {
                                data[key] = data[key][0];
                            }
                        }
                        resolve({ data, files });
                    });
                });
            }
            else {
                await (0, middlewares_1.parseBody)(req);
            }
        }
        try {
            webhookResultData = await workflow.runWebhook(webhookData, workflowStartNode, additionalData, n8n_core_1.NodeExecuteFunctions, executionMode);
            typedi_1.Container.get(events_service_1.EventsService).emit('nodeFetchedData', workflow.id, workflowStartNode);
        }
        catch (err) {
            const errorMessage = 'Workflow Webhook Error: Workflow could not be started!';
            responseCallback(new Error(errorMessage), {});
            didSendResponse = true;
            runExecutionDataMerge = {
                resultData: {
                    runData: {},
                    lastNodeExecuted: workflowStartNode.name,
                    error: {
                        ...err,
                        message: err.message,
                        stack: err.stack,
                    },
                },
            };
            webhookResultData = {
                noWebhookResponse: true,
                workflowData: [[{ json: {} }]],
            };
        }
        await WorkflowHelpers.saveStaticData(workflow);
        const additionalKeys = {
            $executionId: executionId,
        };
        if (webhookData.webhookDescription.responseHeaders !== undefined) {
            const responseHeaders = workflow.expression.getComplexParameterValue(workflowStartNode, webhookData.webhookDescription.responseHeaders, executionMode, additionalData.timezone, additionalKeys, undefined, undefined);
            if (responseHeaders !== undefined && responseHeaders.entries !== undefined) {
                for (const item of responseHeaders.entries) {
                    res.setHeader(item.name, item.value);
                }
            }
        }
        if (webhookResultData.noWebhookResponse === true && !didSendResponse) {
            responseCallback(null, {
                noWebhookResponse: true,
            });
            didSendResponse = true;
        }
        if (webhookResultData.workflowData === undefined) {
            if (webhookResultData.webhookResponse !== undefined) {
                if (!didSendResponse) {
                    responseCallback(null, {
                        data: webhookResultData.webhookResponse,
                        responseCode,
                    });
                    didSendResponse = true;
                }
            }
            else {
                if (!didSendResponse) {
                    responseCallback(null, {
                        data: {
                            message: 'Webhook call received',
                        },
                        responseCode,
                    });
                    didSendResponse = true;
                }
            }
            return;
        }
        if (responseMode === 'onReceived' && !didSendResponse) {
            if (responseData === 'noData') {
                responseCallback(null, {
                    responseCode,
                });
            }
            else if (webhookResultData.webhookResponse !== undefined) {
                responseCallback(null, {
                    data: webhookResultData.webhookResponse,
                    responseCode,
                });
            }
            else {
                responseCallback(null, {
                    data: {
                        message: 'Workflow was started',
                    },
                    responseCode,
                });
            }
            didSendResponse = true;
        }
        const nodeExecutionStack = [];
        nodeExecutionStack.push({
            node: workflowStartNode,
            data: {
                main: webhookResultData.workflowData,
            },
            source: null,
        });
        runExecutionData =
            runExecutionData ||
                {
                    startData: {},
                    resultData: {
                        runData: {},
                    },
                    executionData: {
                        contextData: {},
                        nodeExecutionStack,
                        waitingExecution: {},
                    },
                };
        if (destinationNode && runExecutionData.startData) {
            runExecutionData.startData.destinationNode = destinationNode;
        }
        if (executionId !== undefined) {
            runExecutionData.executionData.nodeExecutionStack[0].data.main =
                webhookResultData.workflowData;
        }
        if (Object.keys(runExecutionDataMerge).length !== 0) {
            Object.assign(runExecutionData, runExecutionDataMerge);
        }
        const runData = {
            executionMode,
            executionData: runExecutionData,
            sessionId,
            workflowData,
            userId: user.id,
        };
        let responsePromise;
        if (responseMode === 'responseNode') {
            responsePromise = await (0, n8n_workflow_1.createDeferredPromise)();
            responsePromise
                .promise()
                .then((response) => {
                var _a;
                if (didSendResponse) {
                    return;
                }
                const binaryData = (_a = response.body) === null || _a === void 0 ? void 0 : _a.binaryData;
                if (binaryData === null || binaryData === void 0 ? void 0 : binaryData.id) {
                    res.header(response.headers);
                    const stream = n8n_core_1.BinaryDataManager.getInstance().getBinaryStream(binaryData.id);
                    void pipeline(stream, res).then(() => responseCallback(null, { noWebhookResponse: true }));
                }
                else if (Buffer.isBuffer(response.body)) {
                    res.header(response.headers);
                    res.end(response.body);
                    responseCallback(null, { noWebhookResponse: true });
                }
                else {
                    responseCallback(null, {
                        data: response.body,
                        headers: response.headers,
                        responseCode: response.statusCode,
                    });
                }
                didSendResponse = true;
            })
                .catch(async (error) => {
                n8n_workflow_1.ErrorReporterProxy.error(error);
                n8n_workflow_1.LoggerProxy.error(`Error with Webhook-Response for execution "${executionId}": "${error.message}"`, { executionId, workflowId: workflow.id });
            });
        }
        const workflowRunner = new WorkflowRunner_1.WorkflowRunner();
        executionId = await workflowRunner.run(runData, true, !didSendResponse, executionId, responsePromise);
        n8n_workflow_1.LoggerProxy.verbose(`Started execution of workflow "${workflow.name}" from webhook with execution ID ${executionId}`, { executionId });
        const executePromise = typedi_1.Container.get(ActiveExecutions_1.ActiveExecutions).getPostExecutePromise(executionId);
        executePromise
            .then(async (data) => {
            if (data === undefined) {
                if (!didSendResponse) {
                    responseCallback(null, {
                        data: {
                            message: 'Workflow executed successfully but no data was returned',
                        },
                        responseCode,
                    });
                    didSendResponse = true;
                }
                return undefined;
            }
            if (workflowData.pinData) {
                data.data.resultData.pinData = workflowData.pinData;
            }
            const returnData = WorkflowHelpers.getDataLastExecutedNodeData(data);
            if (data.data.resultData.error || (returnData === null || returnData === void 0 ? void 0 : returnData.error) !== undefined) {
                if (!didSendResponse) {
                    responseCallback(null, {
                        data: {
                            message: 'Error in workflow',
                        },
                        responseCode: 500,
                    });
                }
                didSendResponse = true;
                return data;
            }
            if (responseMode === 'responseNode') {
                if (!didSendResponse) {
                    responseCallback(null, {
                        data: {
                            message: 'Workflow executed successfully',
                        },
                        responseCode,
                    });
                    didSendResponse = true;
                }
                return undefined;
            }
            if (returnData === undefined) {
                if (!didSendResponse) {
                    responseCallback(null, {
                        data: {
                            message: 'Workflow executed successfully but the last node did not return any data',
                        },
                        responseCode,
                    });
                }
                didSendResponse = true;
                return data;
            }
            const additionalKeys = {
                $executionId: executionId,
            };
            if (!didSendResponse) {
                let data;
                if (responseData === 'firstEntryJson') {
                    if (returnData.data.main[0][0] === undefined) {
                        responseCallback(new Error('No item to return got found'), {});
                        didSendResponse = true;
                        return undefined;
                    }
                    data = returnData.data.main[0][0].json;
                    const responsePropertyName = workflow.expression.getSimpleParameterValue(workflowStartNode, webhookData.webhookDescription.responsePropertyName, executionMode, additionalData.timezone, additionalKeys, undefined, undefined);
                    if (responsePropertyName !== undefined) {
                        data = (0, get_1.default)(data, responsePropertyName);
                    }
                    const responseContentType = workflow.expression.getSimpleParameterValue(workflowStartNode, webhookData.webhookDescription.responseContentType, executionMode, additionalData.timezone, additionalKeys, undefined, undefined);
                    if (responseContentType !== undefined) {
                        res.setHeader('Content-Type', responseContentType);
                        if (data !== null &&
                            data !== undefined &&
                            ['Buffer', 'String'].includes(data.constructor.name)) {
                            res.end(data);
                        }
                        else {
                            res.end(JSON.stringify(data));
                        }
                        responseCallback(null, {
                            noWebhookResponse: true,
                        });
                        didSendResponse = true;
                    }
                }
                else if (responseData === 'firstEntryBinary') {
                    data = returnData.data.main[0][0];
                    if (data === undefined) {
                        responseCallback(new Error('No item was found to return'), {});
                        didSendResponse = true;
                        return undefined;
                    }
                    if (data.binary === undefined) {
                        responseCallback(new Error('No binary data was found to return'), {});
                        didSendResponse = true;
                        return undefined;
                    }
                    const responseBinaryPropertyName = workflow.expression.getSimpleParameterValue(workflowStartNode, webhookData.webhookDescription.responseBinaryPropertyName, executionMode, additionalData.timezone, additionalKeys, undefined, 'data');
                    if (responseBinaryPropertyName === undefined && !didSendResponse) {
                        responseCallback(new Error("No 'responseBinaryPropertyName' is set"), {});
                        didSendResponse = true;
                    }
                    const binaryData = data.binary[responseBinaryPropertyName];
                    if (binaryData === undefined && !didSendResponse) {
                        responseCallback(new Error(`The binary property '${responseBinaryPropertyName}' which should be returned does not exist`), {});
                        didSendResponse = true;
                    }
                    if (!didSendResponse) {
                        res.setHeader('Content-Type', binaryData.mimeType);
                        if (binaryData.id) {
                            const stream = n8n_core_1.BinaryDataManager.getInstance().getBinaryStream(binaryData.id);
                            await pipeline(stream, res);
                        }
                        else {
                            res.end(Buffer.from(binaryData.data, n8n_workflow_1.BINARY_ENCODING));
                        }
                        responseCallback(null, {
                            noWebhookResponse: true,
                        });
                    }
                }
                else if (responseData === 'noData') {
                    data = undefined;
                }
                else {
                    data = [];
                    for (const entry of returnData.data.main[0]) {
                        data.push(entry.json);
                    }
                }
                if (!didSendResponse) {
                    responseCallback(null, {
                        data,
                        responseCode,
                    });
                }
            }
            didSendResponse = true;
            return data;
        })
            .catch((e) => {
            if (!didSendResponse) {
                responseCallback(new Error('There was a problem executing the workflow'), {});
            }
            throw new ResponseHelper.InternalServerError(e.message);
        });
        return executionId;
    }
    catch (e) {
        const error = e instanceof ResponseHelper.UnprocessableRequestError
            ? e
            : new Error('There was a problem executing the workflow', { cause: e });
        if (didSendResponse)
            throw error;
        responseCallback(error, {});
        return;
    }
}
exports.executeWebhook = executeWebhook;
function getWebhookBaseUrl() {
    var _a;
    let urlBaseWebhook = (_a = process.env.WEBHOOK_URL) !== null && _a !== void 0 ? _a : GenericHelpers.getBaseUrl();
    if (!urlBaseWebhook.endsWith('/')) {
        urlBaseWebhook += '/';
    }
    return urlBaseWebhook;
}
exports.getWebhookBaseUrl = getWebhookBaseUrl;
//# sourceMappingURL=WebhookHelpers.js.map