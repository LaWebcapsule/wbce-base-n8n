"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bodyParser = exports.parseBody = exports.rawBodyReader = void 0;
const content_disposition_1 = require("content-disposition");
const content_type_1 = require("content-type");
const raw_body_1 = __importDefault(require("raw-body"));
const querystring_1 = require("querystring");
const xml2js_1 = require("xml2js");
const n8n_workflow_1 = require("n8n-workflow");
const config_1 = __importDefault(require("../config"));
const ResponseHelper_1 = require("../ResponseHelper");
const xmlParser = new xml2js_1.Parser({
    async: true,
    normalize: true,
    normalizeTags: true,
    explicitArray: false,
});
const payloadSizeMax = config_1.default.getEnv('endpoints.payloadSizeMax');
const rawBodyReader = async (req, res, next) => {
    var _a;
    if ('content-type' in req.headers) {
        const { type: contentType, parameters } = (() => {
            try {
                return (0, content_type_1.parse)(req);
            }
            catch {
                return { type: undefined, parameters: undefined };
            }
        })();
        req.contentType = contentType;
        req.encoding = ((_a = parameters === null || parameters === void 0 ? void 0 : parameters.charset) !== null && _a !== void 0 ? _a : 'utf-8').toLowerCase();
        const contentDispositionHeader = req.headers['content-disposition'];
        if (contentDispositionHeader === null || contentDispositionHeader === void 0 ? void 0 : contentDispositionHeader.length) {
            const { type, parameters: { filename }, } = (0, content_disposition_1.parse)(contentDispositionHeader);
            req.contentDisposition = { type, filename };
        }
    }
    req.readRawBody = async () => {
        if (!req.rawBody) {
            req.rawBody = await (0, raw_body_1.default)(req, {
                length: req.headers['content-length'],
                limit: `${String(payloadSizeMax)}mb`,
            });
            req._body = true;
        }
    };
    next();
};
exports.rawBodyReader = rawBodyReader;
const parseBody = async (req) => {
    await req.readRawBody();
    const { rawBody, contentType, encoding } = req;
    if (rawBody === null || rawBody === void 0 ? void 0 : rawBody.length) {
        try {
            if (contentType === 'application/json') {
                req.body = (0, n8n_workflow_1.jsonParse)(rawBody.toString(encoding));
            }
            else if ((contentType === null || contentType === void 0 ? void 0 : contentType.endsWith('/xml')) || (contentType === null || contentType === void 0 ? void 0 : contentType.endsWith('+xml'))) {
                req.body = await xmlParser.parseStringPromise(rawBody.toString(encoding));
            }
            else if (contentType === 'application/x-www-form-urlencoded') {
                req.body = (0, querystring_1.parse)(rawBody.toString(encoding), undefined, undefined, {
                    maxKeys: 1000,
                });
            }
            else if (contentType === 'text/plain') {
                req.body = rawBody.toString(encoding);
            }
        }
        catch (error) {
            throw new ResponseHelper_1.UnprocessableRequestError('Failed to parse request body', error.message);
        }
    }
};
exports.parseBody = parseBody;
const bodyParser = async (req, res, next) => {
    await (0, exports.parseBody)(req);
    if (!req.body)
        req.body = {};
    next();
};
exports.bodyParser = bodyParser;
//# sourceMappingURL=bodyParser.js.map