"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceControlImportService = void 0;
const typedi_1 = __importStar(require("typedi"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("./constants");
const Db = __importStar(require("../../Db"));
const fast_glob_1 = __importDefault(require("fast-glob"));
const n8n_workflow_1 = require("n8n-workflow");
const promises_1 = require("fs/promises");
const n8n_core_1 = require("n8n-core");
const BaseCommand_1 = require("../../commands/BaseCommand");
const SharedCredentials_1 = require("../../databases/entities/SharedCredentials");
const ActiveWorkflowRunner_1 = require("../../ActiveWorkflowRunner");
const typeorm_1 = require("typeorm");
const ResponseHelper_1 = require("../../ResponseHelper");
const sourceControlHelper_ee_1 = require("./sourceControlHelper.ee");
const role_service_1 = require("../../services/role.service");
const variables_service_1 = require("../variables/variables.service");
const repositories_1 = require("../../databases/repositories");
let SourceControlImportService = exports.SourceControlImportService = class SourceControlImportService {
    constructor(variablesService, activeWorkflowRunner, tagRepository) {
        this.variablesService = variablesService;
        this.activeWorkflowRunner = activeWorkflowRunner;
        this.tagRepository = tagRepository;
        const userFolder = n8n_core_1.UserSettings.getUserN8nFolderPath();
        this.gitFolder = path_1.default.join(userFolder, constants_1.SOURCE_CONTROL_GIT_FOLDER);
        this.workflowExportFolder = path_1.default.join(this.gitFolder, constants_1.SOURCE_CONTROL_WORKFLOW_EXPORT_FOLDER);
        this.credentialExportFolder = path_1.default.join(this.gitFolder, constants_1.SOURCE_CONTROL_CREDENTIAL_EXPORT_FOLDER);
    }
    async getOwnerGlobalRole() {
        const globalOwnerRole = await typedi_1.default.get(role_service_1.RoleService).findGlobalOwnerRole();
        if (!globalOwnerRole) {
            throw new Error(`Failed to find owner. ${BaseCommand_1.UM_FIX_INSTRUCTION}`);
        }
        return globalOwnerRole;
    }
    async getCredentialOwnerRole() {
        const credentialOwnerRole = await typedi_1.default.get(role_service_1.RoleService).findCredentialOwnerRole();
        if (!credentialOwnerRole) {
            throw new Error(`Failed to find owner. ${BaseCommand_1.UM_FIX_INSTRUCTION}`);
        }
        return credentialOwnerRole;
    }
    async getWorkflowOwnerRole() {
        const workflowOwnerRole = await typedi_1.default.get(role_service_1.RoleService).findWorkflowOwnerRole();
        if (!workflowOwnerRole) {
            throw new Error(`Failed to find owner workflow role. ${BaseCommand_1.UM_FIX_INSTRUCTION}`);
        }
        return workflowOwnerRole;
    }
    async importCredentialsFromFiles(userId) {
        const credentialFiles = await (0, fast_glob_1.default)('*.json', {
            cwd: this.credentialExportFolder,
            absolute: true,
        });
        const existingCredentials = await Db.collections.Credentials.find();
        const ownerCredentialRole = await this.getCredentialOwnerRole();
        const ownerGlobalRole = await this.getOwnerGlobalRole();
        const encryptionKey = await n8n_core_1.UserSettings.getEncryptionKey();
        let importCredentialsResult = [];
        importCredentialsResult = await Promise.all(credentialFiles.map(async (file) => {
            n8n_workflow_1.LoggerProxy.debug(`Importing credentials file ${file}`);
            const credential = (0, n8n_workflow_1.jsonParse)(await (0, promises_1.readFile)(file, { encoding: 'utf8' }));
            const existingCredential = existingCredentials.find((e) => e.id === credential.id && e.type === credential.type);
            const sharedOwner = await Db.collections.SharedCredentials.findOne({
                select: ['userId'],
                where: {
                    credentialsId: credential.id,
                    roleId: (0, typeorm_1.In)([ownerCredentialRole.id, ownerGlobalRole.id]),
                },
            });
            const { name, type, data, id, nodesAccess } = credential;
            const newCredentialObject = new n8n_core_1.Credentials({ id, name }, type, []);
            if (existingCredential === null || existingCredential === void 0 ? void 0 : existingCredential.data) {
                newCredentialObject.data = existingCredential.data;
            }
            else {
                newCredentialObject.setData(data, encryptionKey);
            }
            newCredentialObject.nodesAccess = nodesAccess || (existingCredential === null || existingCredential === void 0 ? void 0 : existingCredential.nodesAccess) || [];
            n8n_workflow_1.LoggerProxy.debug(`Updating credential id ${newCredentialObject.id}`);
            await Db.collections.Credentials.upsert(newCredentialObject, ['id']);
            if (!sharedOwner) {
                const newSharedCredential = new SharedCredentials_1.SharedCredentials();
                newSharedCredential.credentialsId = newCredentialObject.id;
                newSharedCredential.userId = userId;
                newSharedCredential.roleId = ownerGlobalRole.id;
                await Db.collections.SharedCredentials.upsert({ ...newSharedCredential }, [
                    'credentialsId',
                    'userId',
                ]);
            }
            return {
                id: newCredentialObject.id,
                name: newCredentialObject.name,
                type: newCredentialObject.type,
            };
        }));
        return importCredentialsResult.filter((e) => e !== undefined);
    }
    async getRemoteVersionIdsFromFiles() {
        const remoteWorkflowFiles = await (0, fast_glob_1.default)('*.json', {
            cwd: this.workflowExportFolder,
            absolute: true,
        });
        const remoteWorkflowFilesParsed = await Promise.all(remoteWorkflowFiles.map(async (file) => {
            n8n_workflow_1.LoggerProxy.debug(`Parsing workflow file ${file}`);
            const remote = (0, n8n_workflow_1.jsonParse)(await (0, promises_1.readFile)(file, { encoding: 'utf8' }));
            if (!(remote === null || remote === void 0 ? void 0 : remote.id)) {
                return undefined;
            }
            return {
                id: remote.id,
                versionId: remote.versionId,
                name: remote.name,
                remoteId: remote.id,
                filename: (0, sourceControlHelper_ee_1.getWorkflowExportPath)(remote.id, this.workflowExportFolder),
            };
        }));
        return remoteWorkflowFilesParsed.filter((e) => e !== undefined);
    }
    async getLocalVersionIdsFromDb() {
        const localWorkflows = await Db.collections.Workflow.find({
            select: ['id', 'name', 'versionId', 'updatedAt'],
        });
        return localWorkflows.map((local) => ({
            id: local.id,
            versionId: local.versionId,
            name: local.name,
            localId: local.id,
            filename: (0, sourceControlHelper_ee_1.getWorkflowExportPath)(local.id, this.workflowExportFolder),
            updatedAt: local.updatedAt.toISOString(),
        }));
    }
    async getRemoteCredentialsFromFiles() {
        const remoteCredentialFiles = await (0, fast_glob_1.default)('*.json', {
            cwd: this.credentialExportFolder,
            absolute: true,
        });
        const remoteCredentialFilesParsed = await Promise.all(remoteCredentialFiles.map(async (file) => {
            n8n_workflow_1.LoggerProxy.debug(`Parsing credential file ${file}`);
            const remote = (0, n8n_workflow_1.jsonParse)(await (0, promises_1.readFile)(file, { encoding: 'utf8' }));
            if (!(remote === null || remote === void 0 ? void 0 : remote.id)) {
                return undefined;
            }
            return {
                ...remote,
                filename: (0, sourceControlHelper_ee_1.getCredentialExportPath)(remote.id, this.credentialExportFolder),
            };
        }));
        return remoteCredentialFilesParsed.filter((e) => e !== undefined);
    }
    async getLocalCredentialsFromDb() {
        const localCredentials = await Db.collections.Credentials.find({
            select: ['id', 'name', 'type', 'nodesAccess'],
        });
        return localCredentials.map((local) => ({
            id: local.id,
            name: local.name,
            type: local.type,
            nodesAccess: local.nodesAccess,
            filename: (0, sourceControlHelper_ee_1.getCredentialExportPath)(local.id, this.credentialExportFolder),
        }));
    }
    async getRemoteVariablesFromFile() {
        const variablesFile = await (0, fast_glob_1.default)(constants_1.SOURCE_CONTROL_VARIABLES_EXPORT_FILE, {
            cwd: this.gitFolder,
            absolute: true,
        });
        if (variablesFile.length > 0) {
            n8n_workflow_1.LoggerProxy.debug(`Importing variables from file ${variablesFile[0]}`);
            return (0, n8n_workflow_1.jsonParse)(await (0, promises_1.readFile)(variablesFile[0], { encoding: 'utf8' }), {
                fallbackValue: [],
            });
        }
        return [];
    }
    async getLocalVariablesFromDb() {
        return this.variablesService.getAllCached();
    }
    async getRemoteTagsAndMappingsFromFile() {
        const tagsFile = await (0, fast_glob_1.default)(constants_1.SOURCE_CONTROL_TAGS_EXPORT_FILE, {
            cwd: this.gitFolder,
            absolute: true,
        });
        if (tagsFile.length > 0) {
            n8n_workflow_1.LoggerProxy.debug(`Importing tags from file ${tagsFile[0]}`);
            const mappedTags = (0, n8n_workflow_1.jsonParse)(await (0, promises_1.readFile)(tagsFile[0], { encoding: 'utf8' }), { fallbackValue: { tags: [], mappings: [] } });
            return mappedTags;
        }
        return { tags: [], mappings: [] };
    }
    async getLocalTagsAndMappingsFromDb() {
        const localTags = await this.tagRepository.find({
            select: ['id', 'name'],
        });
        const localMappings = await Db.collections.WorkflowTagMapping.find({
            select: ['workflowId', 'tagId'],
        });
        return { tags: localTags, mappings: localMappings };
    }
    async importWorkflowFromWorkFolder(candidates, userId) {
        const ownerWorkflowRole = await this.getWorkflowOwnerRole();
        const workflowRunner = this.activeWorkflowRunner;
        const candidateIds = candidates.map((c) => c.id);
        const existingWorkflows = await Db.collections.Workflow.find({
            where: {
                id: (0, typeorm_1.In)(candidateIds),
            },
            select: ['id', 'name', 'versionId', 'active'],
        });
        const allSharedWorkflows = await Db.collections.SharedWorkflow.find({
            where: {
                workflowId: (0, typeorm_1.In)(candidateIds),
            },
            select: ['workflowId', 'roleId', 'userId'],
        });
        const cachedOwnerIds = new Map();
        const importWorkflowsResult = await Promise.all(candidates.map(async (candidate) => {
            var _a, _b, _c, _d, _e, _f;
            n8n_workflow_1.LoggerProxy.debug(`Parsing workflow file ${candidate.file}`);
            const importedWorkflow = (0, n8n_workflow_1.jsonParse)(await (0, promises_1.readFile)(candidate.file, { encoding: 'utf8' }));
            if (!(importedWorkflow === null || importedWorkflow === void 0 ? void 0 : importedWorkflow.id)) {
                return;
            }
            const existingWorkflow = existingWorkflows.find((e) => e.id === importedWorkflow.id);
            importedWorkflow.active = (_a = existingWorkflow === null || existingWorkflow === void 0 ? void 0 : existingWorkflow.active) !== null && _a !== void 0 ? _a : false;
            n8n_workflow_1.LoggerProxy.debug(`Updating workflow id ${(_b = importedWorkflow.id) !== null && _b !== void 0 ? _b : 'new'}`);
            const upsertResult = await Db.collections.Workflow.upsert({ ...importedWorkflow }, ['id']);
            if (((_c = upsertResult === null || upsertResult === void 0 ? void 0 : upsertResult.identifiers) === null || _c === void 0 ? void 0 : _c.length) !== 1) {
                throw new Error(`Failed to upsert workflow ${(_d = importedWorkflow.id) !== null && _d !== void 0 ? _d : 'new'}`);
            }
            let workflowOwnerId = userId;
            if (cachedOwnerIds.has(importedWorkflow.owner)) {
                workflowOwnerId = (_e = cachedOwnerIds.get(importedWorkflow.owner)) !== null && _e !== void 0 ? _e : userId;
            }
            else {
                const foundUser = await Db.collections.User.findOne({
                    where: {
                        email: importedWorkflow.owner,
                    },
                    select: ['id'],
                });
                if (foundUser) {
                    cachedOwnerIds.set(importedWorkflow.owner, foundUser.id);
                    workflowOwnerId = foundUser.id;
                }
            }
            const existingSharedWorkflowOwnerByRoleId = allSharedWorkflows.find((e) => e.workflowId === importedWorkflow.id &&
                e.roleId.toString() === ownerWorkflowRole.id.toString());
            const existingSharedWorkflowOwnerByUserId = allSharedWorkflows.find((e) => e.workflowId === importedWorkflow.id &&
                e.roleId.toString() === workflowOwnerId.toString());
            if (!existingSharedWorkflowOwnerByUserId && !existingSharedWorkflowOwnerByRoleId) {
                await Db.collections.SharedWorkflow.insert({
                    workflowId: importedWorkflow.id,
                    userId: workflowOwnerId,
                    roleId: ownerWorkflowRole.id,
                });
            }
            else if (existingSharedWorkflowOwnerByRoleId) {
            }
            else if (existingSharedWorkflowOwnerByUserId && !existingSharedWorkflowOwnerByRoleId) {
                await Db.collections.SharedWorkflow.update({
                    workflowId: importedWorkflow.id,
                    userId: workflowOwnerId,
                }, {
                    roleId: ownerWorkflowRole.id,
                });
            }
            if (existingWorkflow === null || existingWorkflow === void 0 ? void 0 : existingWorkflow.active) {
                try {
                    n8n_workflow_1.LoggerProxy.debug(`Deactivating workflow id ${existingWorkflow.id}`);
                    await workflowRunner.remove(existingWorkflow.id);
                    n8n_workflow_1.LoggerProxy.debug(`Reactivating workflow id ${existingWorkflow.id}`);
                    await workflowRunner.add(existingWorkflow.id, 'activate');
                }
                catch (error) {
                    n8n_workflow_1.LoggerProxy.error(`Failed to activate workflow ${existingWorkflow.id}`, error);
                }
                finally {
                    await Db.collections.Workflow.update({ id: existingWorkflow.id }, { versionId: importedWorkflow.versionId });
                }
            }
            return {
                id: (_f = importedWorkflow.id) !== null && _f !== void 0 ? _f : 'unknown',
                name: candidate.file,
            };
        }));
        return importWorkflowsResult.filter((e) => e !== undefined);
    }
    async importCredentialsFromWorkFolder(candidates, userId) {
        const candidateIds = candidates.map((c) => c.id);
        const existingCredentials = await Db.collections.Credentials.find({
            where: {
                id: (0, typeorm_1.In)(candidateIds),
            },
            select: ['id', 'name', 'type', 'data'],
        });
        const ownerCredentialRole = await this.getCredentialOwnerRole();
        const ownerGlobalRole = await this.getOwnerGlobalRole();
        const existingSharedCredentials = await Db.collections.SharedCredentials.find({
            select: ['userId', 'credentialsId', 'roleId'],
            where: {
                credentialsId: (0, typeorm_1.In)(candidateIds),
                roleId: (0, typeorm_1.In)([ownerCredentialRole.id, ownerGlobalRole.id]),
            },
        });
        const encryptionKey = await n8n_core_1.UserSettings.getEncryptionKey();
        let importCredentialsResult = [];
        importCredentialsResult = await Promise.all(candidates.map(async (candidate) => {
            n8n_workflow_1.LoggerProxy.debug(`Importing credentials file ${candidate.file}`);
            const credential = (0, n8n_workflow_1.jsonParse)(await (0, promises_1.readFile)(candidate.file, { encoding: 'utf8' }));
            const existingCredential = existingCredentials.find((e) => e.id === credential.id && e.type === credential.type);
            const sharedOwner = existingSharedCredentials.find((e) => e.credentialsId === credential.id);
            const { name, type, data, id, nodesAccess } = credential;
            const newCredentialObject = new n8n_core_1.Credentials({ id, name }, type, []);
            if (existingCredential === null || existingCredential === void 0 ? void 0 : existingCredential.data) {
                newCredentialObject.data = existingCredential.data;
            }
            else {
                newCredentialObject.setData(data, encryptionKey);
            }
            newCredentialObject.nodesAccess = nodesAccess || (existingCredential === null || existingCredential === void 0 ? void 0 : existingCredential.nodesAccess) || [];
            n8n_workflow_1.LoggerProxy.debug(`Updating credential id ${newCredentialObject.id}`);
            await Db.collections.Credentials.upsert(newCredentialObject, ['id']);
            if (!sharedOwner) {
                const newSharedCredential = new SharedCredentials_1.SharedCredentials();
                newSharedCredential.credentialsId = newCredentialObject.id;
                newSharedCredential.userId = userId;
                newSharedCredential.roleId = ownerCredentialRole.id;
                await Db.collections.SharedCredentials.upsert({ ...newSharedCredential }, [
                    'credentialsId',
                    'userId',
                ]);
            }
            return {
                id: newCredentialObject.id,
                name: newCredentialObject.name,
                type: newCredentialObject.type,
            };
        }));
        return importCredentialsResult.filter((e) => e !== undefined);
    }
    async importTagsFromWorkFolder(candidate) {
        let mappedTags;
        try {
            n8n_workflow_1.LoggerProxy.debug(`Importing tags from file ${candidate.file}`);
            mappedTags = (0, n8n_workflow_1.jsonParse)(await (0, promises_1.readFile)(candidate.file, { encoding: 'utf8' }), { fallbackValue: { tags: [], mappings: [] } });
        }
        catch (error) {
            n8n_workflow_1.LoggerProxy.error(`Failed to import tags from file ${candidate.file}`, error);
            return;
        }
        if (mappedTags.mappings.length === 0 && mappedTags.tags.length === 0) {
            return;
        }
        const existingWorkflowIds = new Set((await Db.collections.Workflow.find({
            select: ['id'],
        })).map((e) => e.id));
        await Promise.all(mappedTags.tags.map(async (tag) => {
            const findByName = await this.tagRepository.findOne({
                where: { name: tag.name },
                select: ['id'],
            });
            if (findByName && findByName.id !== tag.id) {
                throw new Error(`A tag with the name <strong>${tag.name}</strong> already exists locally.<br />Please either rename the local tag, or the remote one with the id <strong>${tag.id}</strong> in the tags.json file.`);
            }
            const tagCopy = this.tagRepository.create(tag);
            await this.tagRepository.upsert(tagCopy, {
                skipUpdateIfNoValuesChanged: true,
                conflictPaths: { id: true },
            });
        }));
        await Promise.all(mappedTags.mappings.map(async (mapping) => {
            if (!existingWorkflowIds.has(String(mapping.workflowId)))
                return;
            await Db.collections.WorkflowTagMapping.upsert({ tagId: String(mapping.tagId), workflowId: String(mapping.workflowId) }, {
                skipUpdateIfNoValuesChanged: true,
                conflictPaths: { tagId: true, workflowId: true },
            });
        }));
        return mappedTags;
    }
    async importVariablesFromWorkFolder(candidate, valueOverrides) {
        const result = { imported: [] };
        let importedVariables;
        try {
            n8n_workflow_1.LoggerProxy.debug(`Importing variables from file ${candidate.file}`);
            importedVariables = (0, n8n_workflow_1.jsonParse)(await (0, promises_1.readFile)(candidate.file, { encoding: 'utf8' }), { fallbackValue: [] });
        }
        catch (error) {
            n8n_workflow_1.LoggerProxy.error(`Failed to import tags from file ${candidate.file}`, error);
            return;
        }
        const overriddenKeys = Object.keys(valueOverrides !== null && valueOverrides !== void 0 ? valueOverrides : {});
        for (const variable of importedVariables) {
            if (!variable.key) {
                continue;
            }
            if (variable.value === '') {
                variable.value = undefined;
            }
            if (overriddenKeys.includes(variable.key) && valueOverrides) {
                variable.value = valueOverrides[variable.key];
                overriddenKeys.splice(overriddenKeys.indexOf(variable.key), 1);
            }
            try {
                await Db.collections.Variables.upsert({ ...variable }, ['id']);
            }
            catch (errorUpsert) {
                if ((0, ResponseHelper_1.isUniqueConstraintError)(errorUpsert)) {
                    n8n_workflow_1.LoggerProxy.debug(`Variable ${variable.key} already exists, updating instead`);
                    try {
                        await Db.collections.Variables.update({ key: variable.key }, { ...variable });
                    }
                    catch (errorUpdate) {
                        n8n_workflow_1.LoggerProxy.debug(`Failed to update variable ${variable.key}, skipping`);
                        n8n_workflow_1.LoggerProxy.debug(errorUpdate.message);
                    }
                }
            }
            finally {
                result.imported.push(variable.key);
            }
        }
        if (overriddenKeys.length > 0 && valueOverrides) {
            for (const key of overriddenKeys) {
                result.imported.push(key);
                const newVariable = Db.collections.Variables.create({ key, value: valueOverrides[key] });
                await Db.collections.Variables.save(newVariable);
            }
        }
        await this.variablesService.updateCache();
        return result;
    }
};
exports.SourceControlImportService = SourceControlImportService = __decorate([
    (0, typedi_1.Service)(),
    __metadata("design:paramtypes", [variables_service_1.VariablesService,
        ActiveWorkflowRunner_1.ActiveWorkflowRunner,
        repositories_1.TagRepository])
], SourceControlImportService);
//# sourceMappingURL=sourceControlImport.service.ee.js.map