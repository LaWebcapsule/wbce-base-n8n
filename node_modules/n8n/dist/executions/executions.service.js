"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecutionsService = void 0;
const jsonschema_1 = require("jsonschema");
const n8n_workflow_1 = require("n8n-workflow");
const typeorm_1 = require("typeorm");
const ActiveExecutions_1 = require("../ActiveExecutions");
const config_1 = __importDefault(require("../config"));
const NodeTypes_1 = require("../NodeTypes");
const Queue_1 = require("../Queue");
const ResponseHelper = __importStar(require("../ResponseHelper"));
const WorkflowHelpers_1 = require("../WorkflowHelpers");
const WorkflowRunner_1 = require("../WorkflowRunner");
const Db = __importStar(require("../Db"));
const GenericHelpers = __importStar(require("../GenericHelpers"));
const typedi_1 = require("typedi");
const executionHelpers_1 = require("./executionHelpers");
const repositories_1 = require("../databases/repositories");
const schemaGetExecutionsQueryFilter = {
    $id: '/IGetExecutionsQueryFilter',
    type: 'object',
    properties: {
        id: { type: 'string' },
        finished: { type: 'boolean' },
        mode: { type: 'string' },
        retryOf: { type: 'string' },
        retrySuccessId: { type: 'string' },
        status: {
            type: 'array',
            items: { type: 'string' },
        },
        waitTill: { type: 'boolean' },
        workflowId: { anyOf: [{ type: 'integer' }, { type: 'string' }] },
        metadata: { type: 'array', items: { $ref: '#/$defs/metadata' } },
        startedAfter: { type: 'date-time' },
        startedBefore: { type: 'date-time' },
    },
    $defs: {
        metadata: {
            type: 'object',
            required: ['key', 'value'],
            properties: {
                key: {
                    type: 'string',
                },
                value: { type: 'string' },
            },
        },
    },
};
const allowedExecutionsQueryFilterFields = Object.keys(schemaGetExecutionsQueryFilter.properties);
class ExecutionsService {
    static async getWorkflowIdsForUser(user) {
        return (0, WorkflowHelpers_1.getSharedWorkflowIds)(user, ['owner']);
    }
    static async getExecutionsList(req) {
        var _a;
        const sharedWorkflowIds = await this.getWorkflowIdsForUser(req.user);
        if (sharedWorkflowIds.length === 0) {
            return {
                count: 0,
                estimated: false,
                results: [],
            };
        }
        let filter = undefined;
        if (req.query.filter) {
            try {
                const filterJson = (0, n8n_workflow_1.jsonParse)(req.query.filter);
                if (filterJson) {
                    Object.keys(filterJson).map((key) => {
                        if (!allowedExecutionsQueryFilterFields.includes(key))
                            delete filterJson[key];
                    });
                    if ((0, jsonschema_1.validate)(filterJson, schemaGetExecutionsQueryFilter).valid) {
                        filter = filterJson;
                    }
                }
            }
            catch (error) {
                n8n_workflow_1.LoggerProxy.error('Failed to parse filter', {
                    userId: req.user.id,
                    filter: req.query.filter,
                });
                throw new ResponseHelper.InternalServerError('Parameter "filter" contained invalid JSON string.');
            }
        }
        const workflowId = (_a = filter === null || filter === void 0 ? void 0 : filter.workflowId) === null || _a === void 0 ? void 0 : _a.toString();
        if (workflowId !== undefined && !sharedWorkflowIds.includes(workflowId)) {
            n8n_workflow_1.LoggerProxy.verbose(`User ${req.user.id} attempted to query non-shared workflow ${workflowId}`);
            return {
                count: 0,
                estimated: false,
                results: [],
            };
        }
        const limit = req.query.limit
            ? parseInt(req.query.limit, 10)
            : GenericHelpers.DEFAULT_EXECUTIONS_GET_ALL_LIMIT;
        const executingWorkflowIds = [];
        if (config_1.default.getEnv('executions.mode') === 'queue') {
            const queue = typedi_1.Container.get(Queue_1.Queue);
            const currentJobs = await queue.getJobs(['active', 'waiting']);
            executingWorkflowIds.push(...currentJobs.map(({ data }) => data.executionId));
        }
        executingWorkflowIds.push(...typedi_1.Container.get(ActiveExecutions_1.ActiveExecutions)
            .getActiveExecutions()
            .map(({ id }) => id));
        const { count, estimated } = await typedi_1.Container.get(repositories_1.ExecutionRepository).countExecutions(filter, sharedWorkflowIds, executingWorkflowIds, req.user.globalRole.name === 'owner');
        const formattedExecutions = await typedi_1.Container.get(repositories_1.ExecutionRepository).searchExecutions(filter, limit, executingWorkflowIds, sharedWorkflowIds, {
            lastId: req.query.lastId,
            firstId: req.query.firstId,
        });
        return {
            count,
            results: formattedExecutions,
            estimated,
        };
    }
    static async getExecution(req) {
        const sharedWorkflowIds = await this.getWorkflowIdsForUser(req.user);
        if (!sharedWorkflowIds.length)
            return undefined;
        const { id: executionId } = req.params;
        const execution = await typedi_1.Container.get(repositories_1.ExecutionRepository).findSingleExecution(executionId, {
            where: {
                id: executionId,
                workflowId: (0, typeorm_1.In)(sharedWorkflowIds),
            },
            includeData: true,
            unflattenData: false,
        });
        if (!execution) {
            n8n_workflow_1.LoggerProxy.info('Attempt to read execution was blocked due to insufficient permissions', {
                userId: req.user.id,
                executionId,
            });
            return undefined;
        }
        if (!execution.status) {
            execution.status = (0, executionHelpers_1.getStatusUsingPreviousExecutionStatusMethod)(execution);
        }
        return execution;
    }
    static async retryExecution(req) {
        const sharedWorkflowIds = await this.getWorkflowIdsForUser(req.user);
        if (!sharedWorkflowIds.length)
            return false;
        const { id: executionId } = req.params;
        const execution = await typedi_1.Container.get(repositories_1.ExecutionRepository).findSingleExecution(executionId, {
            where: {
                workflowId: (0, typeorm_1.In)(sharedWorkflowIds),
            },
            includeData: true,
            unflattenData: true,
        });
        if (!execution) {
            n8n_workflow_1.LoggerProxy.info('Attempt to retry an execution was blocked due to insufficient permissions', {
                userId: req.user.id,
                executionId,
            });
            throw new ResponseHelper.NotFoundError(`The execution with the ID "${executionId}" does not exist.`);
        }
        if (execution.finished) {
            throw new Error('The execution succeeded, so it cannot be retried.');
        }
        const executionMode = 'retry';
        execution.workflowData.active = false;
        const data = {
            executionMode,
            executionData: execution.data,
            retryOf: req.params.id,
            workflowData: execution.workflowData,
            userId: req.user.id,
        };
        const { lastNodeExecuted } = data.executionData.resultData;
        if (lastNodeExecuted) {
            delete data.executionData.resultData.error;
            const { length } = data.executionData.resultData.runData[lastNodeExecuted];
            if (length > 0 &&
                data.executionData.resultData.runData[lastNodeExecuted][length - 1].error !== undefined) {
                data.executionData.resultData.runData[lastNodeExecuted].pop();
            }
        }
        if (req.body.loadWorkflow) {
            const workflowId = execution.workflowData.id;
            const workflowData = (await Db.collections.Workflow.findOneBy({
                id: workflowId,
            }));
            if (workflowData === undefined) {
                throw new Error(`The workflow with the ID "${workflowId}" could not be found and so the data not be loaded for the retry.`);
            }
            data.workflowData = workflowData;
            const nodeTypes = typedi_1.Container.get(NodeTypes_1.NodeTypes);
            const workflowInstance = new n8n_workflow_1.Workflow({
                id: workflowData.id,
                name: workflowData.name,
                nodes: workflowData.nodes,
                connections: workflowData.connections,
                active: false,
                nodeTypes,
                staticData: undefined,
                settings: workflowData.settings,
            });
            for (const stack of data.executionData.executionData.nodeExecutionStack) {
                const node = workflowInstance.getNode(stack.node.name);
                if (node === null) {
                    n8n_workflow_1.LoggerProxy.error('Failed to retry an execution because a node could not be found', {
                        userId: req.user.id,
                        executionId,
                        nodeName: stack.node.name,
                    });
                    throw new Error(`Could not find the node "${stack.node.name}" in workflow. It probably got deleted or renamed. Without it the workflow can sadly not be retried.`);
                }
                stack.node = node;
            }
        }
        const workflowRunner = new WorkflowRunner_1.WorkflowRunner();
        const retriedExecutionId = await workflowRunner.run(data);
        const executionData = await typedi_1.Container.get(ActiveExecutions_1.ActiveExecutions).getPostExecutePromise(retriedExecutionId);
        if (!executionData) {
            throw new Error('The retry did not start for an unknown reason.');
        }
        return !!executionData.finished;
    }
    static async deleteExecutions(req) {
        const sharedWorkflowIds = await this.getWorkflowIdsForUser(req.user);
        if (sharedWorkflowIds.length === 0) {
            return;
        }
        const { deleteBefore, ids, filters: requestFiltersRaw } = req.body;
        let requestFilters;
        if (requestFiltersRaw) {
            try {
                Object.keys(requestFiltersRaw).map((key) => {
                    if (!allowedExecutionsQueryFilterFields.includes(key))
                        delete requestFiltersRaw[key];
                });
                if ((0, jsonschema_1.validate)(requestFiltersRaw, schemaGetExecutionsQueryFilter).valid) {
                    requestFilters = requestFiltersRaw;
                }
            }
            catch (error) {
                throw new ResponseHelper.InternalServerError('Parameter "filter" contained invalid JSON string.');
            }
        }
        return typedi_1.Container.get(repositories_1.ExecutionRepository).deleteExecutions(requestFilters, sharedWorkflowIds, {
            deleteBefore,
            ids,
        });
    }
}
exports.ExecutionsService = ExecutionsService;
//# sourceMappingURL=executions.service.js.map