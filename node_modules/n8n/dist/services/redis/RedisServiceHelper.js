"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultRedisClient = exports.getRedisClusterClient = exports.getRedisStandardClient = exports.getRedisPrefix = exports.getRedisClusterNodes = exports.WORKER_RESPONSE_REDIS_LIST = exports.WORKER_RESPONSE_REDIS_CHANNEL = exports.COMMAND_REDIS_CHANNEL = exports.EVENT_BUS_REDIS_CHANNEL = exports.WORKER_RESPONSE_REDIS_STREAM = exports.COMMAND_REDIS_STREAM = exports.EVENT_BUS_REDIS_STREAM = void 0;
const config_1 = __importDefault(require("../../config"));
const n8n_workflow_1 = require("n8n-workflow");
exports.EVENT_BUS_REDIS_STREAM = 'n8n:eventstream';
exports.COMMAND_REDIS_STREAM = 'n8n:commandstream';
exports.WORKER_RESPONSE_REDIS_STREAM = 'n8n:workerstream';
exports.EVENT_BUS_REDIS_CHANNEL = 'n8n.events';
exports.COMMAND_REDIS_CHANNEL = 'n8n.commands';
exports.WORKER_RESPONSE_REDIS_CHANNEL = 'n8n.worker-response';
exports.WORKER_RESPONSE_REDIS_LIST = 'n8n:list:worker-response';
function getRedisClusterNodes() {
    const clusterNodePairs = config_1.default
        .getEnv('queue.bull.redis.clusterNodes')
        .split(',')
        .filter((e) => e);
    return clusterNodePairs.map((pair) => {
        const [host, port] = pair.split(':');
        return { host, port: parseInt(port) };
    });
}
exports.getRedisClusterNodes = getRedisClusterNodes;
function getRedisPrefix(customPrefix) {
    let prefix = customPrefix !== null && customPrefix !== void 0 ? customPrefix : config_1.default.getEnv('redis.prefix');
    if (prefix && getRedisClusterNodes().length > 0) {
        if (!prefix.startsWith('{')) {
            prefix = '{' + prefix;
        }
        if (!prefix.endsWith('}')) {
            prefix += '}';
        }
    }
    return prefix;
}
exports.getRedisPrefix = getRedisPrefix;
function getRedisStandardClient(redis, redisOptions, redisType) {
    let lastTimer = 0;
    let cumulativeTimeout = 0;
    const { host, port, username, password, db } = config_1.default.getEnv('queue.bull.redis');
    const redisConnectionTimeoutLimit = config_1.default.getEnv('queue.bull.redis.timeoutThreshold');
    const sharedRedisOptions = {
        ...redisOptions,
        host,
        port,
        username,
        password,
        db,
        enableReadyCheck: false,
        maxRetriesPerRequest: null,
    };
    n8n_workflow_1.LoggerProxy.debug(`Initialising Redis client${redisType ? ` of type ${redisType}` : ''} connection with host: ${host !== null && host !== void 0 ? host : 'localhost'} and port: ${port !== null && port !== void 0 ? port : '6379'}`);
    return new redis({
        ...sharedRedisOptions,
        retryStrategy: () => {
            const now = Date.now();
            if (now - lastTimer > 30000) {
                lastTimer = now;
                cumulativeTimeout = 0;
            }
            else {
                cumulativeTimeout += now - lastTimer;
                lastTimer = now;
                if (cumulativeTimeout > redisConnectionTimeoutLimit) {
                    n8n_workflow_1.LoggerProxy.error(`Unable to connect to Redis after ${redisConnectionTimeoutLimit}. Exiting process.`);
                    process.exit(1);
                }
            }
            return 500;
        },
    });
}
exports.getRedisStandardClient = getRedisStandardClient;
function getRedisClusterClient(redis, redisOptions, redisType) {
    let lastTimer = 0;
    let cumulativeTimeout = 0;
    const clusterNodes = getRedisClusterNodes();
    const { username, password, db } = config_1.default.getEnv('queue.bull.redis');
    const redisConnectionTimeoutLimit = config_1.default.getEnv('queue.bull.redis.timeoutThreshold');
    const sharedRedisOptions = {
        ...redisOptions,
        username,
        password,
        db,
        enableReadyCheck: false,
        maxRetriesPerRequest: null,
    };
    n8n_workflow_1.LoggerProxy.debug(`Initialising Redis cluster${redisType ? ` of type ${redisType}` : ''} connection with nodes: ${clusterNodes.map((e) => `${e.host}:${e.port}`).join(',')}`);
    return new redis.Cluster(clusterNodes.map((node) => ({ host: node.host, port: node.port })), {
        redisOptions: sharedRedisOptions,
        clusterRetryStrategy: () => {
            const now = Date.now();
            if (now - lastTimer > 30000) {
                lastTimer = now;
                cumulativeTimeout = 0;
            }
            else {
                cumulativeTimeout += now - lastTimer;
                lastTimer = now;
                if (cumulativeTimeout > redisConnectionTimeoutLimit) {
                    n8n_workflow_1.LoggerProxy.error(`Unable to connect to Redis after ${redisConnectionTimeoutLimit}. Exiting process.`);
                    process.exit(1);
                }
            }
            return 500;
        },
    });
}
exports.getRedisClusterClient = getRedisClusterClient;
async function getDefaultRedisClient(additionalRedisOptions, redisType) {
    const { default: Redis } = await Promise.resolve().then(() => __importStar(require('ioredis')));
    const clusterNodes = getRedisClusterNodes();
    const usesRedisCluster = clusterNodes.length > 0;
    return usesRedisCluster
        ? getRedisClusterClient(Redis, additionalRedisOptions, redisType)
        : getRedisStandardClient(Redis, additionalRedisOptions, redisType);
}
exports.getDefaultRedisClient = getDefaultRedisClient;
//# sourceMappingURL=RedisServiceHelper.js.map