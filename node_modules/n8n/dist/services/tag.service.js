"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TagService = void 0;
const repositories_1 = require("../databases/repositories");
const typedi_1 = require("typedi");
const GenericHelpers_1 = require("../GenericHelpers");
const ExternalHooks_1 = require("../ExternalHooks");
let TagService = exports.TagService = class TagService {
    constructor(externalHooks, tagRepository) {
        this.externalHooks = externalHooks;
        this.tagRepository = tagRepository;
    }
    toEntity(attrs) {
        attrs.name = attrs.name.trim();
        return this.tagRepository.create(attrs);
    }
    async save(tag, actionKind) {
        await (0, GenericHelpers_1.validateEntity)(tag);
        const action = actionKind[0].toUpperCase() + actionKind.slice(1);
        await this.externalHooks.run(`tag.before${action}`, [tag]);
        const savedTag = this.tagRepository.save(tag);
        await this.externalHooks.run(`tag.after${action}`, [tag]);
        return savedTag;
    }
    async delete(id) {
        await this.externalHooks.run('tag.beforeDelete', [id]);
        const deleteResult = this.tagRepository.delete(id);
        await this.externalHooks.run('tag.afterDelete', [id]);
        return deleteResult;
    }
    async findOne(options) {
        return this.tagRepository.findOne(options);
    }
    async findMany(options) {
        return this.tagRepository.find(options);
    }
    async upsert(tag, options) {
        return this.tagRepository.upsert(tag, options);
    }
    async getAll(options) {
        if (options === null || options === void 0 ? void 0 : options.withUsageCount) {
            const allTags = await this.tagRepository.find({
                select: ['id', 'name', 'createdAt', 'updatedAt'],
                relations: ['workflowMappings'],
            });
            return allTags.map(({ workflowMappings, ...rest }) => {
                return {
                    ...rest,
                    usageCount: workflowMappings.length,
                };
            });
        }
        return this.tagRepository.find({
            select: ['id', 'name', 'createdAt', 'updatedAt'],
        });
    }
    sortByRequestOrder(tags, { requestOrder }) {
        const tagMap = tags.reduce((acc, tag) => {
            acc[tag.id] = tag;
            return acc;
        }, {});
        return requestOrder.map((tagId) => tagMap[tagId]);
    }
    async setTagsForImport(transactionManager, workflow, tags) {
        var _a;
        if (!this.hasTags(workflow))
            return;
        const workflowTags = workflow.tags;
        const tagLookupPromises = [];
        for (let i = 0; i < workflowTags.length; i++) {
            if ((_a = workflowTags[i]) === null || _a === void 0 ? void 0 : _a.name) {
                const lookupPromise = this.findOrCreateTag(transactionManager, workflowTags[i], tags).then((tag) => {
                    workflowTags[i] = {
                        id: tag.id,
                        name: tag.name,
                    };
                });
                tagLookupPromises.push(lookupPromise);
            }
        }
        await Promise.all(tagLookupPromises);
    }
    hasTags(workflow) {
        return 'tags' in workflow && Array.isArray(workflow.tags) && workflow.tags.length > 0;
    }
    async findOrCreateTag(transactionManager, importTag, tagsEntities) {
        const identicalMatch = tagsEntities.find((existingTag) => existingTag.id === importTag.id &&
            existingTag.createdAt &&
            importTag.createdAt &&
            existingTag.createdAt.getTime() === new Date(importTag.createdAt).getTime());
        if (identicalMatch) {
            return identicalMatch;
        }
        const nameMatch = tagsEntities.find((existingTag) => existingTag.name === importTag.name);
        if (nameMatch) {
            return nameMatch;
        }
        const created = await this.txCreateTag(transactionManager, importTag.name);
        tagsEntities.push(created);
        return created;
    }
    async txCreateTag(transactionManager, name) {
        const tag = this.tagRepository.create({ name: name.trim() });
        return transactionManager.save(tag);
    }
};
exports.TagService = TagService = __decorate([
    (0, typedi_1.Service)(),
    __metadata("design:paramtypes", [ExternalHooks_1.ExternalHooks,
        repositories_1.TagRepository])
], TagService);
//# sourceMappingURL=tag.service.js.map