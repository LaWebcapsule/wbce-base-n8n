import { TagRepository } from '../databases/repositories';
import type { ITagWithCountDb, IWorkflowToImport } from '../Interfaces';
import type { TagEntity } from '../databases/entities/TagEntity';
import type { EntityManager, FindManyOptions, FindOneOptions } from 'typeorm';
import type { UpsertOptions } from 'typeorm/repository/UpsertOptions';
import { ExternalHooks } from '../ExternalHooks';
type GetAllResult<T> = T extends {
    withUsageCount: true;
} ? ITagWithCountDb[] : TagEntity[];
export declare class TagService {
    private externalHooks;
    private tagRepository;
    constructor(externalHooks: ExternalHooks, tagRepository: TagRepository);
    toEntity(attrs: {
        name: string;
        id?: string;
    }): TagEntity;
    save(tag: TagEntity, actionKind: 'create' | 'update'): Promise<TagEntity>;
    delete(id: string): Promise<import("typeorm").DeleteResult>;
    findOne(options: FindOneOptions<TagEntity>): Promise<TagEntity | null>;
    findMany(options: FindManyOptions<TagEntity>): Promise<TagEntity[]>;
    upsert(tag: TagEntity, options: UpsertOptions<TagEntity>): Promise<import("typeorm").InsertResult>;
    getAll<T extends {
        withUsageCount: boolean;
    }>(options?: T): Promise<GetAllResult<T>>;
    sortByRequestOrder(tags: TagEntity[], { requestOrder }: {
        requestOrder: string[];
    }): TagEntity[];
    setTagsForImport(transactionManager: EntityManager, workflow: IWorkflowToImport, tags: TagEntity[]): Promise<void>;
    private hasTags;
    private findOrCreateTag;
    private txCreateTag;
}
export {};
