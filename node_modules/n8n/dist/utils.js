"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isObjectLiteral = exports.isIntegerString = exports.isStringArray = exports.toError = exports.webhookNotFoundErrorMessage = exports.separate = exports.alphabetizeKeys = exports.findCliWorkflowStart = exports.findSubworkflowStart = exports.isWorkflowIdValid = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const constants_1 = require("./constants");
function isWorkflowIdValid(id) {
    return typeof id === 'string' && (id === null || id === void 0 ? void 0 : id.length) <= 16;
}
exports.isWorkflowIdValid = isWorkflowIdValid;
function findWorkflowStart(executionMode) {
    return function (nodes) {
        const executeWorkflowTriggerNode = nodes.find((node) => node.type === 'n8n-nodes-base.executeWorkflowTrigger');
        if (executeWorkflowTriggerNode)
            return executeWorkflowTriggerNode;
        const startNode = nodes.find((node) => constants_1.STARTING_NODES.includes(node.type));
        if (startNode)
            return startNode;
        const title = 'Missing node to start execution';
        const description = "Please make sure the workflow you're calling contains an Execute Workflow Trigger node";
        if (executionMode === 'integrated') {
            throw new n8n_workflow_1.SubworkflowOperationError(title, description);
        }
        throw new n8n_workflow_1.CliWorkflowOperationError(title, description);
    };
}
exports.findSubworkflowStart = findWorkflowStart('integrated');
exports.findCliWorkflowStart = findWorkflowStart('cli');
const alphabetizeKeys = (obj) => Object.keys(obj)
    .sort()
    .reduce((acc, key) => ({
    ...acc,
    [key]: obj[key],
}), {});
exports.alphabetizeKeys = alphabetizeKeys;
const separate = (array, test) => {
    const pass = [];
    const fail = [];
    array.forEach((i) => (test(i) ? pass : fail).push(i));
    return [pass, fail];
};
exports.separate = separate;
const webhookNotFoundErrorMessage = (path, httpMethod, webhookMethods) => {
    let webhookPath = path;
    if (httpMethod) {
        webhookPath = `${httpMethod} ${webhookPath}`;
    }
    if ((webhookMethods === null || webhookMethods === void 0 ? void 0 : webhookMethods.length) && httpMethod) {
        let methods = '';
        if (webhookMethods.length === 1) {
            methods = webhookMethods[0];
        }
        else {
            const lastMethod = webhookMethods.pop();
            methods = `${webhookMethods.join(', ')} or ${lastMethod}`;
        }
        return `This webhook is not registered for ${httpMethod} requests. Did you mean to make a ${methods} request?`;
    }
    else {
        return `The requested webhook "${webhookPath}" is not registered.`;
    }
};
exports.webhookNotFoundErrorMessage = webhookNotFoundErrorMessage;
const toError = (maybeError) => maybeError instanceof Error ? maybeError : new Error(`${maybeError}`);
exports.toError = toError;
function isStringArray(value) {
    return Array.isArray(value) && value.every((item) => typeof item === 'string');
}
exports.isStringArray = isStringArray;
const isIntegerString = (value) => /^\d+$/.test(value);
exports.isIntegerString = isIntegerString;
function isObjectLiteral(item) {
    return typeof item === 'object' && item !== null && !Array.isArray(item);
}
exports.isObjectLiteral = isObjectLiteral;
//# sourceMappingURL=utils.js.map