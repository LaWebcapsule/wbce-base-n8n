"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PasswordResetController = void 0;
const typeorm_1 = require("typeorm");
const validator_1 = __importDefault(require("validator"));
const decorators_1 = require("../decorators");
const ResponseHelper_1 = require("../ResponseHelper");
const UserManagementHelper_1 = require("../UserManagement/UserManagementHelper");
const jwt_1 = require("../auth/jwt");
const helpers_1 = require("../Ldap/helpers");
const ssoHelpers_1 = require("../sso/ssoHelpers");
const user_service_1 = require("../services/user.service");
const License_1 = require("../License");
const typedi_1 = require("typedi");
const constants_1 = require("../constants");
const jsonwebtoken_1 = require("jsonwebtoken");
const jwt_service_1 = require("../services/jwt.service");
let PasswordResetController = exports.PasswordResetController = class PasswordResetController {
    constructor({ config, logger, externalHooks, internalHooks, mailer, }) {
        this.config = config;
        this.logger = logger;
        this.externalHooks = externalHooks;
        this.internalHooks = internalHooks;
        this.mailer = mailer;
        this.jwtService = typedi_1.Container.get(jwt_service_1.JwtService);
        this.userService = typedi_1.Container.get(user_service_1.UserService);
    }
    async forgotPassword(req) {
        var _a, _b;
        if (this.config.getEnv('userManagement.emails.mode') === '') {
            this.logger.debug('Request to send password reset email failed because emailing was not set up');
            throw new ResponseHelper_1.InternalServerError('Email sending must be set up in order to request a password reset email');
        }
        const { email } = req.body;
        if (!email) {
            this.logger.debug('Request to send password reset email failed because of missing email in payload', { payload: req.body });
            throw new ResponseHelper_1.BadRequestError('Email is mandatory');
        }
        if (!validator_1.default.isEmail(email)) {
            this.logger.debug('Request to send password reset email failed because of invalid email in payload', { invalidEmail: email });
            throw new ResponseHelper_1.BadRequestError('Invalid email address');
        }
        const user = await this.userService.findOne({
            where: {
                email,
                password: (0, typeorm_1.Not)((0, typeorm_1.IsNull)()),
            },
            relations: ['authIdentities', 'globalRole'],
        });
        if (!(user === null || user === void 0 ? void 0 : user.isOwner) && !typedi_1.Container.get(License_1.License).isWithinUsersLimit()) {
            this.logger.debug('Request to send password reset email failed because the user limit was reached');
            throw new ResponseHelper_1.UnauthorizedError(constants_1.RESPONSE_ERROR_MESSAGES.USERS_QUOTA_REACHED);
        }
        if ((0, ssoHelpers_1.isSamlCurrentAuthenticationMethod)() &&
            !((user === null || user === void 0 ? void 0 : user.globalRole.name) === 'owner' || ((_a = user === null || user === void 0 ? void 0 : user.settings) === null || _a === void 0 ? void 0 : _a.allowSSOManualLogin) === true)) {
            this.logger.debug('Request to send password reset email failed because login is handled by SAML');
            throw new ResponseHelper_1.UnauthorizedError('Login is handled by SAML. Please contact your Identity Provider to reset your password.');
        }
        const ldapIdentity = (_b = user === null || user === void 0 ? void 0 : user.authIdentities) === null || _b === void 0 ? void 0 : _b.find((i) => i.providerType === 'ldap');
        if (!(user === null || user === void 0 ? void 0 : user.password) || (ldapIdentity && user.disabled)) {
            this.logger.debug('Request to send password reset email failed because no user was found for the provided email', { invalidEmail: email });
            return;
        }
        if ((0, helpers_1.isLdapEnabled)() && ldapIdentity) {
            throw new ResponseHelper_1.UnprocessableRequestError('forgotPassword.ldapUserPasswordResetUnavailable');
        }
        const baseUrl = (0, UserManagementHelper_1.getInstanceBaseUrl)();
        const { id, firstName, lastName } = user;
        const resetPasswordToken = this.jwtService.signData({ sub: id }, {
            expiresIn: '1d',
        });
        const url = this.userService.generatePasswordResetUrl(baseUrl, resetPasswordToken);
        try {
            await this.mailer.passwordReset({
                email,
                firstName,
                lastName,
                passwordResetUrl: url,
                domain: baseUrl,
            });
        }
        catch (error) {
            void this.internalHooks.onEmailFailed({
                user,
                message_type: 'Reset password',
                public_api: false,
            });
            if (error instanceof Error) {
                throw new ResponseHelper_1.InternalServerError(`Please contact your administrator: ${error.message}`);
            }
        }
        this.logger.info('Sent password reset email successfully', { userId: user.id, email });
        void this.internalHooks.onUserTransactionalEmail({
            user_id: id,
            message_type: 'Reset password',
            public_api: false,
        });
        void this.internalHooks.onUserPasswordResetRequestClick({ user });
    }
    async resolvePasswordToken(req) {
        const { token: resetPasswordToken } = req.query;
        if (!resetPasswordToken) {
            this.logger.debug('Request to resolve password token failed because of missing password reset token', {
                queryString: req.query,
            });
            throw new ResponseHelper_1.BadRequestError('');
        }
        const decodedToken = this.verifyResetPasswordToken(resetPasswordToken);
        const user = await this.userService.findOne({
            where: { id: decodedToken.sub },
            relations: ['globalRole'],
        });
        if (!(user === null || user === void 0 ? void 0 : user.isOwner) && !typedi_1.Container.get(License_1.License).isWithinUsersLimit()) {
            this.logger.debug('Request to resolve password token failed because the user limit was reached', { userId: decodedToken.sub });
            throw new ResponseHelper_1.UnauthorizedError(constants_1.RESPONSE_ERROR_MESSAGES.USERS_QUOTA_REACHED);
        }
        if (!user) {
            this.logger.debug('Request to resolve password token failed because no user was found for the provided user ID', {
                userId: decodedToken.sub,
                resetPasswordToken,
            });
            throw new ResponseHelper_1.NotFoundError('');
        }
        this.logger.info('Reset-password token resolved successfully', { userId: user.id });
        void this.internalHooks.onUserPasswordResetEmailClick({ user });
    }
    async changePassword(req, res) {
        var _a;
        const { token: resetPasswordToken, password } = req.body;
        if (!resetPasswordToken || !password) {
            this.logger.debug('Request to change password failed because of missing user ID or password or reset password token in payload', {
                payload: req.body,
            });
            throw new ResponseHelper_1.BadRequestError('Missing user ID or password or reset password token');
        }
        const validPassword = (0, UserManagementHelper_1.validatePassword)(password);
        const decodedToken = this.verifyResetPasswordToken(resetPasswordToken);
        const user = await this.userService.findOne({
            where: { id: decodedToken.sub },
            relations: ['authIdentities'],
        });
        if (!user) {
            this.logger.debug('Request to resolve password token failed because no user was found for the provided user ID', {
                resetPasswordToken,
            });
            throw new ResponseHelper_1.NotFoundError('');
        }
        const passwordHash = await (0, UserManagementHelper_1.hashPassword)(validPassword);
        await this.userService.update(user.id, { password: passwordHash });
        this.logger.info('User password updated successfully', { userId: user.id });
        await (0, jwt_1.issueCookie)(res, user);
        void this.internalHooks.onUserUpdate({
            user,
            fields_changed: ['password'],
        });
        const ldapIdentity = (_a = user === null || user === void 0 ? void 0 : user.authIdentities) === null || _a === void 0 ? void 0 : _a.find((i) => i.providerType === 'ldap');
        if (ldapIdentity) {
            void this.internalHooks.onUserSignup(user, {
                user_type: 'email',
                was_disabled_ldap_user: true,
            });
        }
        await this.externalHooks.run('user.password.update', [user.email, passwordHash]);
    }
    verifyResetPasswordToken(resetPasswordToken) {
        let decodedToken;
        try {
            decodedToken = this.jwtService.verifyToken(resetPasswordToken);
            return decodedToken;
        }
        catch (e) {
            if (e instanceof jsonwebtoken_1.TokenExpiredError) {
                this.logger.debug('Reset password token expired', {
                    resetPasswordToken,
                });
                throw new ResponseHelper_1.NotFoundError('');
            }
            this.logger.debug('Error verifying token', {
                resetPasswordToken,
            });
            throw new ResponseHelper_1.BadRequestError('');
        }
    }
};
__decorate([
    (0, decorators_1.Post)('/forgot-password'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], PasswordResetController.prototype, "forgotPassword", null);
__decorate([
    (0, decorators_1.Get)('/resolve-password-token'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], PasswordResetController.prototype, "resolvePasswordToken", null);
__decorate([
    (0, decorators_1.Post)('/change-password'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], PasswordResetController.prototype, "changePassword", null);
exports.PasswordResetController = PasswordResetController = __decorate([
    (0, decorators_1.RestController)(),
    __metadata("design:paramtypes", [Object])
], PasswordResetController);
//# sourceMappingURL=passwordReset.controller.js.map