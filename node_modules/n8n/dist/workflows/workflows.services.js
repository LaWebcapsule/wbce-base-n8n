"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowsService = void 0;
const typedi_1 = require("typedi");
const n8n_workflow_1 = require("n8n-workflow");
const typeorm_1 = require("typeorm");
const pick_1 = __importDefault(require("lodash/pick"));
const uuid_1 = require("uuid");
const ActiveWorkflowRunner_1 = require("../ActiveWorkflowRunner");
const Db = __importStar(require("../Db"));
const ResponseHelper = __importStar(require("../ResponseHelper"));
const WorkflowHelpers = __importStar(require("../WorkflowHelpers"));
const config_1 = __importDefault(require("../config"));
const GenericHelpers_1 = require("../GenericHelpers");
const ExternalHooks_1 = require("../ExternalHooks");
const requests_1 = require("../requests");
const tag_service_1 = require("../services/tag.service");
const NodeTypes_1 = require("../NodeTypes");
const WorkflowRunner_1 = require("../WorkflowRunner");
const WorkflowExecuteAdditionalData = __importStar(require("../WorkflowExecuteAdditionalData"));
const TestWebhooks_1 = require("../TestWebhooks");
const UserManagementHelper_1 = require("../UserManagement/UserManagementHelper");
const InternalHooks_1 = require("../InternalHooks");
const repositories_1 = require("../databases/repositories");
const role_service_1 = require("../services/role.service");
const ownership_service_1 = require("../services/ownership.service");
const utils_1 = require("../utils");
class WorkflowsService {
    static async getSharing(user, workflowId, relations = ['workflow'], { allowGlobalOwner } = { allowGlobalOwner: true }) {
        const where = { workflowId };
        if (!allowGlobalOwner || user.globalRole.name !== 'owner') {
            where.userId = user.id;
        }
        return Db.collections.SharedWorkflow.findOne({ where, relations });
    }
    static findPinnedTrigger(workflow, startNodes, pinData) {
        var _a;
        if (!pinData || !startNodes)
            return null;
        const isTrigger = (nodeTypeName) => ['trigger', 'webhook'].some((suffix) => nodeTypeName.toLowerCase().includes(suffix));
        const pinnedTriggers = workflow.nodes.filter((node) => !node.disabled && pinData[node.name] && isTrigger(node.type));
        if (pinnedTriggers.length === 0)
            return null;
        if ((startNodes === null || startNodes === void 0 ? void 0 : startNodes.length) === 0)
            return pinnedTriggers[0];
        const [startNodeName] = startNodes;
        const parentNames = new n8n_workflow_1.Workflow({
            nodes: workflow.nodes,
            connections: workflow.connections,
            active: workflow.active,
            nodeTypes: typedi_1.Container.get(NodeTypes_1.NodeTypes),
        }).getParentNodes(startNodeName);
        let checkNodeName = '';
        if (parentNames.length === 0) {
            checkNodeName = startNodeName;
        }
        else {
            checkNodeName = parentNames.find((pn) => pn === pinnedTriggers[0].name);
        }
        return (_a = pinnedTriggers.find((pt) => pt.name === checkNodeName)) !== null && _a !== void 0 ? _a : null;
    }
    static async get(workflow, options) {
        return Db.collections.Workflow.findOne({ where: workflow, relations: options === null || options === void 0 ? void 0 : options.relations });
    }
    static async getMany(sharedWorkflowIds, options) {
        var _a, _b, _c, _d;
        if (sharedWorkflowIds.length === 0)
            return { workflows: [], count: 0 };
        const where = {
            ...options === null || options === void 0 ? void 0 : options.filter,
            id: (0, typeorm_1.In)(sharedWorkflowIds),
        };
        const reqTags = (_a = options === null || options === void 0 ? void 0 : options.filter) === null || _a === void 0 ? void 0 : _a.tags;
        if ((0, utils_1.isStringArray)(reqTags)) {
            where.tags = reqTags.map((tag) => ({ name: tag }));
        }
        const select = (options === null || options === void 0 ? void 0 : options.select)
            ? { ...options.select }
            : {
                name: true,
                active: true,
                createdAt: true,
                updatedAt: true,
                versionId: true,
                shared: { userId: true, roleId: true },
            };
        select === null || select === void 0 ? true : delete select.ownedBy;
        const relations = [];
        const areTagsEnabled = !config_1.default.getEnv('workflowTagsDisabled');
        const isDefaultSelect = (options === null || options === void 0 ? void 0 : options.select) === undefined;
        const areTagsRequested = isDefaultSelect || ((_b = options === null || options === void 0 ? void 0 : options.select) === null || _b === void 0 ? void 0 : _b.tags) === true;
        const isOwnedByIncluded = isDefaultSelect || ((_c = options === null || options === void 0 ? void 0 : options.select) === null || _c === void 0 ? void 0 : _c.ownedBy) === true;
        if (areTagsEnabled && areTagsRequested) {
            relations.push('tags');
            select.tags = { id: true, name: true };
        }
        if (isOwnedByIncluded)
            relations.push('shared');
        if (typeof where.name === 'string' && where.name !== '') {
            where.name = (0, typeorm_1.Like)(`%${where.name}%`);
        }
        const findManyOptions = {
            select: { ...select, id: true },
            where,
        };
        if (isDefaultSelect || ((_d = options === null || options === void 0 ? void 0 : options.select) === null || _d === void 0 ? void 0 : _d.updatedAt) === true) {
            findManyOptions.order = { updatedAt: 'ASC' };
        }
        if (relations.length > 0) {
            findManyOptions.relations = relations;
        }
        if (options === null || options === void 0 ? void 0 : options.take) {
            findManyOptions.skip = options.skip;
            findManyOptions.take = options.take;
        }
        const [workflows, count] = (await typedi_1.Container.get(repositories_1.WorkflowRepository).findAndCount(findManyOptions));
        if (!(0, requests_1.hasSharing)(workflows))
            return { workflows, count };
        const workflowOwnerRole = await typedi_1.Container.get(role_service_1.RoleService).findWorkflowOwnerRole();
        return {
            workflows: workflows.map((w) => typedi_1.Container.get(ownership_service_1.OwnershipService).addOwnedBy(w, workflowOwnerRole)),
            count,
        };
    }
    static async update(user, workflow, workflowId, tagIds, forceSave, roles) {
        var _a, _b;
        const shared = await Db.collections.SharedWorkflow.findOne({
            relations: ['workflow', 'role'],
            where: (0, UserManagementHelper_1.whereClause)({
                user,
                entityType: 'workflow',
                entityId: workflowId,
                roles,
            }),
        });
        if (!shared) {
            n8n_workflow_1.LoggerProxy.verbose('User attempted to update a workflow without permissions', {
                workflowId,
                userId: user.id,
            });
            throw new ResponseHelper.NotFoundError('You do not have permission to update this workflow. Ask the owner to share it with you.');
        }
        if (!forceSave &&
            workflow.versionId !== '' &&
            workflow.versionId !== shared.workflow.versionId) {
            throw new ResponseHelper.BadRequestError('Your most recent changes may be lost, because someone else just updated this workflow. Open this workflow in a new tab to see those new updates.', 100);
        }
        if (Object.keys(workflow).length === 3 &&
            workflow.id !== undefined &&
            workflow.versionId !== undefined &&
            workflow.active !== undefined) {
        }
        else {
            workflow.versionId = (0, uuid_1.v4)();
            n8n_workflow_1.LoggerProxy.verbose(`Updating versionId for workflow ${workflowId} for user ${user.id} after saving`, {
                previousVersionId: shared.workflow.versionId,
                newVersionId: workflow.versionId,
            });
        }
        await WorkflowHelpers.replaceInvalidCredentials(workflow);
        WorkflowHelpers.addNodeIds(workflow);
        await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('workflow.update', [workflow]);
        if (shared.workflow.active) {
            await typedi_1.Container.get(ActiveWorkflowRunner_1.ActiveWorkflowRunner).remove(workflowId);
        }
        const workflowSettings = (_a = workflow.settings) !== null && _a !== void 0 ? _a : {};
        const keysAllowingDefault = [
            'timezone',
            'saveDataErrorExecution',
            'saveDataSuccessExecution',
            'saveManualExecutions',
            'saveExecutionProgress',
        ];
        for (const key of keysAllowingDefault) {
            if (workflowSettings[key] === 'DEFAULT') {
                delete workflowSettings[key];
            }
        }
        if (workflowSettings.executionTimeout === config_1.default.get('executions.timeout')) {
            delete workflowSettings.executionTimeout;
        }
        if (workflow.name) {
            workflow.updatedAt = new Date();
            await (0, GenericHelpers_1.validateEntity)(workflow);
        }
        await Db.collections.Workflow.update(workflowId, (0, pick_1.default)(workflow, [
            'name',
            'active',
            'nodes',
            'connections',
            'settings',
            'staticData',
            'pinData',
            'versionId',
        ]));
        if (tagIds && !config_1.default.getEnv('workflowTagsDisabled')) {
            await Db.collections.WorkflowTagMapping.delete({ workflowId });
            await Db.collections.WorkflowTagMapping.insert(tagIds.map((tagId) => ({ tagId, workflowId })));
        }
        const relations = config_1.default.getEnv('workflowTagsDisabled') ? [] : ['tags'];
        const updatedWorkflow = await Db.collections.Workflow.findOne({
            where: { id: workflowId },
            relations,
        });
        if (updatedWorkflow === null) {
            throw new ResponseHelper.BadRequestError(`Workflow with ID "${workflowId}" could not be found to be updated.`);
        }
        if (((_b = updatedWorkflow.tags) === null || _b === void 0 ? void 0 : _b.length) && (tagIds === null || tagIds === void 0 ? void 0 : tagIds.length)) {
            updatedWorkflow.tags = typedi_1.Container.get(tag_service_1.TagService).sortByRequestOrder(updatedWorkflow.tags, {
                requestOrder: tagIds,
            });
        }
        await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('workflow.afterUpdate', [updatedWorkflow]);
        void typedi_1.Container.get(InternalHooks_1.InternalHooks).onWorkflowSaved(user, updatedWorkflow, false);
        if (updatedWorkflow.active) {
            try {
                await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('workflow.activate', [updatedWorkflow]);
                await typedi_1.Container.get(ActiveWorkflowRunner_1.ActiveWorkflowRunner).add(workflowId, shared.workflow.active ? 'update' : 'activate');
            }
            catch (error) {
                await Db.collections.Workflow.update(workflowId, {
                    active: false,
                    versionId: shared.workflow.versionId,
                });
                updatedWorkflow.active = false;
                let message;
                if (error instanceof n8n_workflow_1.NodeApiError)
                    message = error.description;
                message = message !== null && message !== void 0 ? message : error.message;
                throw new ResponseHelper.BadRequestError(message);
            }
        }
        return updatedWorkflow;
    }
    static async runManually({ workflowData, runData, pinData, startNodes, destinationNode, }, user, sessionId) {
        var _a;
        const EXECUTION_MODE = 'manual';
        const ACTIVATION_MODE = 'manual';
        const pinnedTrigger = WorkflowsService.findPinnedTrigger(workflowData, startNodes, pinData);
        if (pinnedTrigger === null &&
            (runData === undefined ||
                startNodes === undefined ||
                startNodes.length === 0 ||
                destinationNode === undefined)) {
            const workflow = new n8n_workflow_1.Workflow({
                id: (_a = workflowData.id) === null || _a === void 0 ? void 0 : _a.toString(),
                name: workflowData.name,
                nodes: workflowData.nodes,
                connections: workflowData.connections,
                active: false,
                nodeTypes: typedi_1.Container.get(NodeTypes_1.NodeTypes),
                staticData: undefined,
                settings: workflowData.settings,
            });
            const additionalData = await WorkflowExecuteAdditionalData.getBase(user.id);
            const needsWebhook = await typedi_1.Container.get(TestWebhooks_1.TestWebhooks).needsWebhookData(workflowData, workflow, additionalData, EXECUTION_MODE, ACTIVATION_MODE, sessionId, destinationNode);
            if (needsWebhook) {
                return {
                    waitingForWebhook: true,
                };
            }
        }
        workflowData.active = false;
        const data = {
            destinationNode,
            executionMode: EXECUTION_MODE,
            runData,
            pinData,
            sessionId,
            startNodes,
            workflowData,
            userId: user.id,
        };
        const hasRunData = (node) => runData !== undefined && !!runData[node.name];
        if (pinnedTrigger && !hasRunData(pinnedTrigger)) {
            data.startNodes = [pinnedTrigger.name];
        }
        const workflowRunner = new WorkflowRunner_1.WorkflowRunner();
        const executionId = await workflowRunner.run(data);
        return {
            executionId,
        };
    }
    static async delete(user, workflowId) {
        await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('workflow.delete', [workflowId]);
        const sharedWorkflow = await Db.collections.SharedWorkflow.findOne({
            relations: ['workflow', 'role'],
            where: (0, UserManagementHelper_1.whereClause)({
                user,
                entityType: 'workflow',
                entityId: workflowId,
                roles: ['owner'],
            }),
        });
        if (!sharedWorkflow) {
            return;
        }
        if (sharedWorkflow.workflow.active) {
            await typedi_1.Container.get(ActiveWorkflowRunner_1.ActiveWorkflowRunner).remove(workflowId);
        }
        await Db.collections.Workflow.delete(workflowId);
        void typedi_1.Container.get(InternalHooks_1.InternalHooks).onWorkflowDeleted(user, workflowId, false);
        await typedi_1.Container.get(ExternalHooks_1.ExternalHooks).run('workflow.afterDelete', [workflowId]);
        return sharedWorkflow.workflow;
    }
    static async updateWorkflowTriggerCount(id, triggerCount) {
        const qb = Db.collections.Workflow.createQueryBuilder('workflow');
        return qb
            .update()
            .set({
            triggerCount,
            updatedAt: () => {
                if (['mysqldb', 'mariadb'].includes(config_1.default.getEnv('database.type'))) {
                    return 'updatedAt';
                }
                return '"updatedAt"';
            },
        })
            .where('id = :id', { id })
            .execute();
    }
}
exports.WorkflowsService = WorkflowsService;
//# sourceMappingURL=workflows.services.js.map